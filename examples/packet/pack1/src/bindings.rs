// Generated by `wit-bindgen` 0.21.0. DO NOT EDIT!
// Options used:
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_run_cabi<T: Guest>() {
    T::run();
}
pub trait Guest {
    fn run();
}
#[doc(hidden)]

macro_rules! __export_world_pack_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "run"]
    unsafe extern "C" fn export_run() {
      $($path_to_types)*::_export_run_cabi::<$ty>()
    }
  };);
}
#[doc(hidden)]
pub(crate) use __export_world_pack_cabi;
pub mod acts {
    pub mod packs {
        #[allow(clippy::all)]
        pub mod types {
            #[used]
            #[doc(hidden)]
            #[cfg(target_arch = "wasm32")]
            static __FORCE_SECTION_REF: fn() =
                super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            #[derive(Clone)]
            pub enum Value {
                Null,
                Boolean(bool),
                PosInt(u64),
                NegInt(i64),
                Float(f64),
                Text(_rt::String),
            }
            impl ::core::fmt::Debug for Value {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    match self {
                        Value::Null => f.debug_tuple("Value::Null").finish(),
                        Value::Boolean(e) => f.debug_tuple("Value::Boolean").field(e).finish(),
                        Value::PosInt(e) => f.debug_tuple("Value::PosInt").field(e).finish(),
                        Value::NegInt(e) => f.debug_tuple("Value::NegInt").field(e).finish(),
                        Value::Float(e) => f.debug_tuple("Value::Float").field(e).finish(),
                        Value::Text(e) => f.debug_tuple("Value::Text").field(e).finish(),
                    }
                }
            }
            pub type Map = _rt::Vec<(_rt::String, Value)>;
            #[derive(Clone)]
            pub struct Request {
                pub id: _rt::String,
                pub key: Option<_rt::String>,
                pub tag: Option<_rt::String>,
                pub name: Option<_rt::String>,
                pub inputs: Map,
                pub outputs: Map,
            }
            impl ::core::fmt::Debug for Request {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("Request")
                        .field("id", &self.id)
                        .field("key", &self.key)
                        .field("tag", &self.tag)
                        .field("name", &self.name)
                        .field("inputs", &self.inputs)
                        .field("outputs", &self.outputs)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct Message {
                pub id: _rt::String,
                pub key: Option<_rt::String>,
                pub tag: Option<_rt::String>,
                pub name: Option<_rt::String>,
                pub inputs: Map,
            }
            impl ::core::fmt::Debug for Message {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("Message")
                        .field("id", &self.id)
                        .field("key", &self.key)
                        .field("tag", &self.tag)
                        .field("name", &self.name)
                        .field("inputs", &self.inputs)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct Chain {
                pub ins: _rt::Vec<_rt::String>,
            }
            impl ::core::fmt::Debug for Chain {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("Chain").field("ins", &self.ins).finish()
                }
            }
            #[derive(Clone)]
            pub struct Each {
                pub ins: _rt::Vec<_rt::String>,
            }
            impl ::core::fmt::Debug for Each {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("Each").field("ins", &self.ins).finish()
                }
            }
            #[derive(Clone)]
            pub struct Call {
                pub id: _rt::String,
                pub mid: _rt::String,
                pub inputs: Map,
                pub outputs: Map,
            }
            impl ::core::fmt::Debug for Call {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("Call")
                        .field("id", &self.id)
                        .field("mid", &self.mid)
                        .field("inputs", &self.inputs)
                        .field("outputs", &self.outputs)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub enum Packet {
                Req(Request),
                Msg(Message),
                Chain(Chain),
                Each(Each),
                Call(Call),
            }
            impl ::core::fmt::Debug for Packet {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    match self {
                        Packet::Req(e) => f.debug_tuple("Packet::Req").field(e).finish(),
                        Packet::Msg(e) => f.debug_tuple("Packet::Msg").field(e).finish(),
                        Packet::Chain(e) => f.debug_tuple("Packet::Chain").field(e).finish(),
                        Packet::Each(e) => f.debug_tuple("Packet::Each").field(e).finish(),
                        Packet::Call(e) => f.debug_tuple("Packet::Call").field(e).finish(),
                    }
                }
            }
            #[derive(Clone)]
            pub struct RequestEvents {
                pub on_created: _rt::Vec<Packet>,
                pub on_completed: _rt::Vec<Packet>,
            }
            impl ::core::fmt::Debug for RequestEvents {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("RequestEvents")
                        .field("on-created", &self.on_created)
                        .field("on-completed", &self.on_completed)
                        .finish()
                }
            }
        }

        #[allow(clippy::all)]
        pub mod act {
            #[used]
            #[doc(hidden)]
            #[cfg(target_arch = "wasm32")]
            static __FORCE_SECTION_REF: fn() =
                super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type Value = super::super::super::acts::packs::types::Value;
            pub type Request = super::super::super::acts::packs::types::Request;
            pub type Message = super::super::super::acts::packs::types::Message;
            pub type Packet = super::super::super::acts::packs::types::Packet;
            pub type Call = super::super::super::acts::packs::types::Call;
            pub type Chain = super::super::super::acts::packs::types::Chain;
            pub type Each = super::super::super::acts::packs::types::Each;
            pub type RequestEvents = super::super::super::acts::packs::types::RequestEvents;
            #[allow(unused_unsafe, clippy::all)]
            pub fn inputs() -> _rt::Vec<(_rt::String, Value)> {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "acts:packs/act")]
                    extern "C" {
                        #[link_name = "inputs"]
                        fn wit_import(_: *mut u8);
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8) {
                        unreachable!()
                    }
                    wit_import(ptr0);
                    let l1 = *ptr0.add(0).cast::<*mut u8>();
                    let l2 = *ptr0.add(4).cast::<usize>();
                    let base15 = l1;
                    let len15 = l2;
                    let mut result15 = _rt::Vec::with_capacity(len15);
                    for i in 0..len15 {
                        let base = base15.add(i * 24);
                        let e15 = {
                            let l3 = *base.add(0).cast::<*mut u8>();
                            let l4 = *base.add(4).cast::<usize>();
                            let len5 = l4;
                            let bytes5 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);
                            let l6 = i32::from(*base.add(8).cast::<u8>());
                            use super::super::super::acts::packs::types::Value as V14;
                            let v14 = match l6 {
                                0 => V14::Null,
                                1 => {
                                    let e14 = {
                                        let l7 = i32::from(*base.add(16).cast::<u8>());

                                        _rt::bool_lift(l7 as u8)
                                    };
                                    V14::Boolean(e14)
                                }
                                2 => {
                                    let e14 = {
                                        let l8 = *base.add(16).cast::<i64>();

                                        l8 as u64
                                    };
                                    V14::PosInt(e14)
                                }
                                3 => {
                                    let e14 = {
                                        let l9 = *base.add(16).cast::<i64>();

                                        l9
                                    };
                                    V14::NegInt(e14)
                                }
                                4 => {
                                    let e14 = {
                                        let l10 = *base.add(16).cast::<f64>();

                                        l10
                                    };
                                    V14::Float(e14)
                                }
                                n => {
                                    debug_assert_eq!(n, 5, "invalid enum discriminant");
                                    let e14 = {
                                        let l11 = *base.add(16).cast::<*mut u8>();
                                        let l12 = *base.add(20).cast::<usize>();
                                        let len13 = l12;
                                        let bytes13 =
                                            _rt::Vec::from_raw_parts(l11.cast(), len13, len13);

                                        _rt::string_lift(bytes13)
                                    };
                                    V14::Text(e14)
                                }
                            };

                            (_rt::string_lift(bytes5), v14)
                        };
                        result15.push(e15);
                    }
                    _rt::cabi_dealloc(base15, len15 * 24, 8);
                    result15
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn set_data(key: &str, value: &Value) {
                unsafe {
                    let vec0 = key;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    use super::super::super::acts::packs::types::Value as V2;
                    let (result3_0, result3_1, result3_2) = match value {
                        V2::Null => (0i32, ::core::mem::MaybeUninit::<u64>::zeroed(), 0usize),
                        V2::Boolean(e) => (
                            1i32,
                            ::core::mem::MaybeUninit::new(i64::from(match e {
                                true => 1,
                                false => 0,
                            }) as u64),
                            0usize,
                        ),
                        V2::PosInt(e) => (
                            2i32,
                            ::core::mem::MaybeUninit::new(_rt::as_i64(e) as u64),
                            0usize,
                        ),
                        V2::NegInt(e) => (
                            3i32,
                            ::core::mem::MaybeUninit::new(_rt::as_i64(e) as u64),
                            0usize,
                        ),
                        V2::Float(e) => (
                            4i32,
                            ::core::mem::MaybeUninit::new((_rt::as_f64(e)).to_bits() as i64 as u64),
                            0usize,
                        ),
                        V2::Text(e) => {
                            let vec1 = e;
                            let ptr1 = vec1.as_ptr().cast::<u8>();
                            let len1 = vec1.len();

                            (
                                5i32,
                                {
                                    let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                                    t.as_mut_ptr().cast::<*mut u8>().write(ptr1.cast_mut());
                                    t
                                },
                                len1,
                            )
                        }
                    };

                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "acts:packs/act")]
                    extern "C" {
                        #[link_name = "set-data"]
                        fn wit_import(
                            _: *mut u8,
                            _: usize,
                            _: i32,
                            _: ::core::mem::MaybeUninit<u64>,
                            _: usize,
                        );
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(
                        _: *mut u8,
                        _: usize,
                        _: i32,
                        _: ::core::mem::MaybeUninit<u64>,
                        _: usize,
                    ) {
                        unreachable!()
                    }
                    wit_import(ptr0.cast_mut(), len0, result3_0, result3_1, result3_2);
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn set_output(key: &str, value: &Value) {
                unsafe {
                    let vec0 = key;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    use super::super::super::acts::packs::types::Value as V2;
                    let (result3_0, result3_1, result3_2) = match value {
                        V2::Null => (0i32, ::core::mem::MaybeUninit::<u64>::zeroed(), 0usize),
                        V2::Boolean(e) => (
                            1i32,
                            ::core::mem::MaybeUninit::new(i64::from(match e {
                                true => 1,
                                false => 0,
                            }) as u64),
                            0usize,
                        ),
                        V2::PosInt(e) => (
                            2i32,
                            ::core::mem::MaybeUninit::new(_rt::as_i64(e) as u64),
                            0usize,
                        ),
                        V2::NegInt(e) => (
                            3i32,
                            ::core::mem::MaybeUninit::new(_rt::as_i64(e) as u64),
                            0usize,
                        ),
                        V2::Float(e) => (
                            4i32,
                            ::core::mem::MaybeUninit::new((_rt::as_f64(e)).to_bits() as i64 as u64),
                            0usize,
                        ),
                        V2::Text(e) => {
                            let vec1 = e;
                            let ptr1 = vec1.as_ptr().cast::<u8>();
                            let len1 = vec1.len();

                            (
                                5i32,
                                {
                                    let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                                    t.as_mut_ptr().cast::<*mut u8>().write(ptr1.cast_mut());
                                    t
                                },
                                len1,
                            )
                        }
                    };

                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "acts:packs/act")]
                    extern "C" {
                        #[link_name = "set-output"]
                        fn wit_import(
                            _: *mut u8,
                            _: usize,
                            _: i32,
                            _: ::core::mem::MaybeUninit<u64>,
                            _: usize,
                        );
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(
                        _: *mut u8,
                        _: usize,
                        _: i32,
                        _: ::core::mem::MaybeUninit<u64>,
                        _: usize,
                    ) {
                        unreachable!()
                    }
                    wit_import(ptr0.cast_mut(), len0, result3_0, result3_1, result3_2);
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn complete() {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "acts:packs/act")]
                    extern "C" {
                        #[link_name = "complete"]
                        fn wit_import();
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import() {
                        unreachable!()
                    }
                    wit_import();
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn abort() {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "acts:packs/act")]
                    extern "C" {
                        #[link_name = "abort"]
                        fn wit_import();
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import() {
                        unreachable!()
                    }
                    wit_import();
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn back(nid: &str) {
                unsafe {
                    let vec0 = nid;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();

                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "acts:packs/act")]
                    extern "C" {
                        #[link_name = "back"]
                        fn wit_import(_: *mut u8, _: usize);
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: usize) {
                        unreachable!()
                    }
                    wit_import(ptr0.cast_mut(), len0);
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn fail(ecode: &str, message: &str) {
                unsafe {
                    let vec0 = ecode;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let vec1 = message;
                    let ptr1 = vec1.as_ptr().cast::<u8>();
                    let len1 = vec1.len();

                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "acts:packs/act")]
                    extern "C" {
                        #[link_name = "fail"]
                        fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize);
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize) {
                        unreachable!()
                    }
                    wit_import(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1);
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn skip() {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "acts:packs/act")]
                    extern "C" {
                        #[link_name = "skip"]
                        fn wit_import();
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import() {
                        unreachable!()
                    }
                    wit_import();
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn push(p: &Packet) {
                unsafe {
                    let mut cleanup_list = _rt::Vec::new();
                    use super::super::super::acts::packs::types::Packet as V50;
                    let (
                        result51_0,
                        result51_1,
                        result51_2,
                        result51_3,
                        result51_4,
                        result51_5,
                        result51_6,
                        result51_7,
                        result51_8,
                        result51_9,
                        result51_10,
                        result51_11,
                        result51_12,
                        result51_13,
                        result51_14,
                        result51_15,
                    ) = match p {
                        V50::Req(e) => {
                            let super::super::super::acts::packs::types::Request {
                                id: id0,
                                key: key0,
                                tag: tag0,
                                name: name0,
                                inputs: inputs0,
                                outputs: outputs0,
                            } = e;
                            let vec1 = id0;
                            let ptr1 = vec1.as_ptr().cast::<u8>();
                            let len1 = vec1.len();
                            let (result3_0, result3_1, result3_2) = match key0 {
                                Some(e) => {
                                    let vec2 = e;
                                    let ptr2 = vec2.as_ptr().cast::<u8>();
                                    let len2 = vec2.len();

                                    (1i32, ptr2.cast_mut(), len2)
                                }
                                None => (0i32, ::core::ptr::null_mut(), 0usize),
                            };
                            let (result5_0, result5_1, result5_2) = match tag0 {
                                Some(e) => {
                                    let vec4 = e;
                                    let ptr4 = vec4.as_ptr().cast::<u8>();
                                    let len4 = vec4.len();

                                    (1i32, ptr4.cast_mut(), len4)
                                }
                                None => (0i32, ::core::ptr::null_mut(), 0usize),
                            };
                            let (result7_0, result7_1, result7_2) = match name0 {
                                Some(e) => {
                                    let vec6 = e;
                                    let ptr6 = vec6.as_ptr().cast::<u8>();
                                    let len6 = vec6.len();

                                    (1i32, ptr6.cast_mut(), len6)
                                }
                                None => (0i32, ::core::ptr::null_mut(), 0usize),
                            };
                            let vec12 = inputs0;
                            let len12 = vec12.len();
                            let layout12 =
                                _rt::alloc::Layout::from_size_align_unchecked(vec12.len() * 24, 8);
                            let result12 = if layout12.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout12).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout12);
                                }
                                ptr
                            } else {
                                {
                                    ::core::ptr::null_mut()
                                }
                            };
                            for (i, e) in vec12.into_iter().enumerate() {
                                let base = result12.add(i * 24);
                                {
                                    let (t8_0, t8_1) = e;
                                    let vec9 = t8_0;
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    *base.add(4).cast::<usize>() = len9;
                                    *base.add(0).cast::<*mut u8>() = ptr9.cast_mut();
                                    use super::super::super::acts::packs::types::Value as V11;
                                    match t8_1 {
                                        V11::Null => {
                                            *base.add(8).cast::<u8>() = (0i32) as u8;
                                        }
                                        V11::Boolean(e) => {
                                            *base.add(8).cast::<u8>() = (1i32) as u8;
                                            *base.add(16).cast::<u8>() = (match e {
                                                true => 1,
                                                false => 0,
                                            })
                                                as u8;
                                        }
                                        V11::PosInt(e) => {
                                            *base.add(8).cast::<u8>() = (2i32) as u8;
                                            *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                        }
                                        V11::NegInt(e) => {
                                            *base.add(8).cast::<u8>() = (3i32) as u8;
                                            *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                        }
                                        V11::Float(e) => {
                                            *base.add(8).cast::<u8>() = (4i32) as u8;
                                            *base.add(16).cast::<f64>() = _rt::as_f64(e);
                                        }
                                        V11::Text(e) => {
                                            *base.add(8).cast::<u8>() = (5i32) as u8;
                                            let vec10 = e;
                                            let ptr10 = vec10.as_ptr().cast::<u8>();
                                            let len10 = vec10.len();
                                            *base.add(20).cast::<usize>() = len10;
                                            *base.add(16).cast::<*mut u8>() = ptr10.cast_mut();
                                        }
                                    }
                                }
                            }
                            let vec17 = outputs0;
                            let len17 = vec17.len();
                            let layout17 =
                                _rt::alloc::Layout::from_size_align_unchecked(vec17.len() * 24, 8);
                            let result17 = if layout17.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout17).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout17);
                                }
                                ptr
                            } else {
                                {
                                    ::core::ptr::null_mut()
                                }
                            };
                            for (i, e) in vec17.into_iter().enumerate() {
                                let base = result17.add(i * 24);
                                {
                                    let (t13_0, t13_1) = e;
                                    let vec14 = t13_0;
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    *base.add(4).cast::<usize>() = len14;
                                    *base.add(0).cast::<*mut u8>() = ptr14.cast_mut();
                                    use super::super::super::acts::packs::types::Value as V16;
                                    match t13_1 {
                                        V16::Null => {
                                            *base.add(8).cast::<u8>() = (0i32) as u8;
                                        }
                                        V16::Boolean(e) => {
                                            *base.add(8).cast::<u8>() = (1i32) as u8;
                                            *base.add(16).cast::<u8>() = (match e {
                                                true => 1,
                                                false => 0,
                                            })
                                                as u8;
                                        }
                                        V16::PosInt(e) => {
                                            *base.add(8).cast::<u8>() = (2i32) as u8;
                                            *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                        }
                                        V16::NegInt(e) => {
                                            *base.add(8).cast::<u8>() = (3i32) as u8;
                                            *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                        }
                                        V16::Float(e) => {
                                            *base.add(8).cast::<u8>() = (4i32) as u8;
                                            *base.add(16).cast::<f64>() = _rt::as_f64(e);
                                        }
                                        V16::Text(e) => {
                                            *base.add(8).cast::<u8>() = (5i32) as u8;
                                            let vec15 = e;
                                            let ptr15 = vec15.as_ptr().cast::<u8>();
                                            let len15 = vec15.len();
                                            *base.add(20).cast::<usize>() = len15;
                                            *base.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                        }
                                    }
                                }
                            }
                            cleanup_list
                                .extend_from_slice(&[(result12, layout12), (result17, layout17)]);

                            (
                                0i32,
                                ptr1.cast_mut(),
                                len1,
                                result3_0 as *mut u8,
                                result3_1,
                                result3_2 as *mut u8,
                                result5_0 as usize,
                                result5_1,
                                result5_2,
                                result7_0,
                                result7_1,
                                result7_2,
                                result12,
                                len12,
                                result17,
                                len17,
                            )
                        }
                        V50::Msg(e) => {
                            let super::super::super::acts::packs::types::Message {
                                id: id18,
                                key: key18,
                                tag: tag18,
                                name: name18,
                                inputs: inputs18,
                            } = e;
                            let vec19 = id18;
                            let ptr19 = vec19.as_ptr().cast::<u8>();
                            let len19 = vec19.len();
                            let (result21_0, result21_1, result21_2) = match key18 {
                                Some(e) => {
                                    let vec20 = e;
                                    let ptr20 = vec20.as_ptr().cast::<u8>();
                                    let len20 = vec20.len();

                                    (1i32, ptr20.cast_mut(), len20)
                                }
                                None => (0i32, ::core::ptr::null_mut(), 0usize),
                            };
                            let (result23_0, result23_1, result23_2) = match tag18 {
                                Some(e) => {
                                    let vec22 = e;
                                    let ptr22 = vec22.as_ptr().cast::<u8>();
                                    let len22 = vec22.len();

                                    (1i32, ptr22.cast_mut(), len22)
                                }
                                None => (0i32, ::core::ptr::null_mut(), 0usize),
                            };
                            let (result25_0, result25_1, result25_2) = match name18 {
                                Some(e) => {
                                    let vec24 = e;
                                    let ptr24 = vec24.as_ptr().cast::<u8>();
                                    let len24 = vec24.len();

                                    (1i32, ptr24.cast_mut(), len24)
                                }
                                None => (0i32, ::core::ptr::null_mut(), 0usize),
                            };
                            let vec30 = inputs18;
                            let len30 = vec30.len();
                            let layout30 =
                                _rt::alloc::Layout::from_size_align_unchecked(vec30.len() * 24, 8);
                            let result30 = if layout30.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout30).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout30);
                                }
                                ptr
                            } else {
                                {
                                    ::core::ptr::null_mut()
                                }
                            };
                            for (i, e) in vec30.into_iter().enumerate() {
                                let base = result30.add(i * 24);
                                {
                                    let (t26_0, t26_1) = e;
                                    let vec27 = t26_0;
                                    let ptr27 = vec27.as_ptr().cast::<u8>();
                                    let len27 = vec27.len();
                                    *base.add(4).cast::<usize>() = len27;
                                    *base.add(0).cast::<*mut u8>() = ptr27.cast_mut();
                                    use super::super::super::acts::packs::types::Value as V29;
                                    match t26_1 {
                                        V29::Null => {
                                            *base.add(8).cast::<u8>() = (0i32) as u8;
                                        }
                                        V29::Boolean(e) => {
                                            *base.add(8).cast::<u8>() = (1i32) as u8;
                                            *base.add(16).cast::<u8>() = (match e {
                                                true => 1,
                                                false => 0,
                                            })
                                                as u8;
                                        }
                                        V29::PosInt(e) => {
                                            *base.add(8).cast::<u8>() = (2i32) as u8;
                                            *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                        }
                                        V29::NegInt(e) => {
                                            *base.add(8).cast::<u8>() = (3i32) as u8;
                                            *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                        }
                                        V29::Float(e) => {
                                            *base.add(8).cast::<u8>() = (4i32) as u8;
                                            *base.add(16).cast::<f64>() = _rt::as_f64(e);
                                        }
                                        V29::Text(e) => {
                                            *base.add(8).cast::<u8>() = (5i32) as u8;
                                            let vec28 = e;
                                            let ptr28 = vec28.as_ptr().cast::<u8>();
                                            let len28 = vec28.len();
                                            *base.add(20).cast::<usize>() = len28;
                                            *base.add(16).cast::<*mut u8>() = ptr28.cast_mut();
                                        }
                                    }
                                }
                            }
                            cleanup_list.extend_from_slice(&[(result30, layout30)]);

                            (
                                1i32,
                                ptr19.cast_mut(),
                                len19,
                                result21_0 as *mut u8,
                                result21_1,
                                result21_2 as *mut u8,
                                result23_0 as usize,
                                result23_1,
                                result23_2,
                                result25_0,
                                result25_1,
                                result25_2,
                                result30,
                                len30,
                                ::core::ptr::null_mut(),
                                0usize,
                            )
                        }
                        V50::Chain(e) => {
                            let super::super::super::acts::packs::types::Chain { ins: ins31 } = e;
                            let vec33 = ins31;
                            let len33 = vec33.len();
                            let layout33 =
                                _rt::alloc::Layout::from_size_align_unchecked(vec33.len() * 8, 4);
                            let result33 = if layout33.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout33).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout33);
                                }
                                ptr
                            } else {
                                {
                                    ::core::ptr::null_mut()
                                }
                            };
                            for (i, e) in vec33.into_iter().enumerate() {
                                let base = result33.add(i * 8);
                                {
                                    let vec32 = e;
                                    let ptr32 = vec32.as_ptr().cast::<u8>();
                                    let len32 = vec32.len();
                                    *base.add(4).cast::<usize>() = len32;
                                    *base.add(0).cast::<*mut u8>() = ptr32.cast_mut();
                                }
                            }
                            cleanup_list.extend_from_slice(&[(result33, layout33)]);

                            (
                                2i32,
                                result33,
                                len33,
                                ::core::ptr::null_mut(),
                                ::core::ptr::null_mut(),
                                ::core::ptr::null_mut(),
                                0usize,
                                ::core::ptr::null_mut(),
                                0usize,
                                0i32,
                                ::core::ptr::null_mut(),
                                0usize,
                                ::core::ptr::null_mut(),
                                0usize,
                                ::core::ptr::null_mut(),
                                0usize,
                            )
                        }
                        V50::Each(e) => {
                            let super::super::super::acts::packs::types::Each { ins: ins34 } = e;
                            let vec36 = ins34;
                            let len36 = vec36.len();
                            let layout36 =
                                _rt::alloc::Layout::from_size_align_unchecked(vec36.len() * 8, 4);
                            let result36 = if layout36.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout36).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout36);
                                }
                                ptr
                            } else {
                                {
                                    ::core::ptr::null_mut()
                                }
                            };
                            for (i, e) in vec36.into_iter().enumerate() {
                                let base = result36.add(i * 8);
                                {
                                    let vec35 = e;
                                    let ptr35 = vec35.as_ptr().cast::<u8>();
                                    let len35 = vec35.len();
                                    *base.add(4).cast::<usize>() = len35;
                                    *base.add(0).cast::<*mut u8>() = ptr35.cast_mut();
                                }
                            }
                            cleanup_list.extend_from_slice(&[(result36, layout36)]);

                            (
                                3i32,
                                result36,
                                len36,
                                ::core::ptr::null_mut(),
                                ::core::ptr::null_mut(),
                                ::core::ptr::null_mut(),
                                0usize,
                                ::core::ptr::null_mut(),
                                0usize,
                                0i32,
                                ::core::ptr::null_mut(),
                                0usize,
                                ::core::ptr::null_mut(),
                                0usize,
                                ::core::ptr::null_mut(),
                                0usize,
                            )
                        }
                        V50::Call(e) => {
                            let super::super::super::acts::packs::types::Call {
                                id: id37,
                                mid: mid37,
                                inputs: inputs37,
                                outputs: outputs37,
                            } = e;
                            let vec38 = id37;
                            let ptr38 = vec38.as_ptr().cast::<u8>();
                            let len38 = vec38.len();
                            let vec39 = mid37;
                            let ptr39 = vec39.as_ptr().cast::<u8>();
                            let len39 = vec39.len();
                            let vec44 = inputs37;
                            let len44 = vec44.len();
                            let layout44 =
                                _rt::alloc::Layout::from_size_align_unchecked(vec44.len() * 24, 8);
                            let result44 = if layout44.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout44).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout44);
                                }
                                ptr
                            } else {
                                {
                                    ::core::ptr::null_mut()
                                }
                            };
                            for (i, e) in vec44.into_iter().enumerate() {
                                let base = result44.add(i * 24);
                                {
                                    let (t40_0, t40_1) = e;
                                    let vec41 = t40_0;
                                    let ptr41 = vec41.as_ptr().cast::<u8>();
                                    let len41 = vec41.len();
                                    *base.add(4).cast::<usize>() = len41;
                                    *base.add(0).cast::<*mut u8>() = ptr41.cast_mut();
                                    use super::super::super::acts::packs::types::Value as V43;
                                    match t40_1 {
                                        V43::Null => {
                                            *base.add(8).cast::<u8>() = (0i32) as u8;
                                        }
                                        V43::Boolean(e) => {
                                            *base.add(8).cast::<u8>() = (1i32) as u8;
                                            *base.add(16).cast::<u8>() = (match e {
                                                true => 1,
                                                false => 0,
                                            })
                                                as u8;
                                        }
                                        V43::PosInt(e) => {
                                            *base.add(8).cast::<u8>() = (2i32) as u8;
                                            *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                        }
                                        V43::NegInt(e) => {
                                            *base.add(8).cast::<u8>() = (3i32) as u8;
                                            *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                        }
                                        V43::Float(e) => {
                                            *base.add(8).cast::<u8>() = (4i32) as u8;
                                            *base.add(16).cast::<f64>() = _rt::as_f64(e);
                                        }
                                        V43::Text(e) => {
                                            *base.add(8).cast::<u8>() = (5i32) as u8;
                                            let vec42 = e;
                                            let ptr42 = vec42.as_ptr().cast::<u8>();
                                            let len42 = vec42.len();
                                            *base.add(20).cast::<usize>() = len42;
                                            *base.add(16).cast::<*mut u8>() = ptr42.cast_mut();
                                        }
                                    }
                                }
                            }
                            let vec49 = outputs37;
                            let len49 = vec49.len();
                            let layout49 =
                                _rt::alloc::Layout::from_size_align_unchecked(vec49.len() * 24, 8);
                            let result49 = if layout49.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout49).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout49);
                                }
                                ptr
                            } else {
                                {
                                    ::core::ptr::null_mut()
                                }
                            };
                            for (i, e) in vec49.into_iter().enumerate() {
                                let base = result49.add(i * 24);
                                {
                                    let (t45_0, t45_1) = e;
                                    let vec46 = t45_0;
                                    let ptr46 = vec46.as_ptr().cast::<u8>();
                                    let len46 = vec46.len();
                                    *base.add(4).cast::<usize>() = len46;
                                    *base.add(0).cast::<*mut u8>() = ptr46.cast_mut();
                                    use super::super::super::acts::packs::types::Value as V48;
                                    match t45_1 {
                                        V48::Null => {
                                            *base.add(8).cast::<u8>() = (0i32) as u8;
                                        }
                                        V48::Boolean(e) => {
                                            *base.add(8).cast::<u8>() = (1i32) as u8;
                                            *base.add(16).cast::<u8>() = (match e {
                                                true => 1,
                                                false => 0,
                                            })
                                                as u8;
                                        }
                                        V48::PosInt(e) => {
                                            *base.add(8).cast::<u8>() = (2i32) as u8;
                                            *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                        }
                                        V48::NegInt(e) => {
                                            *base.add(8).cast::<u8>() = (3i32) as u8;
                                            *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                        }
                                        V48::Float(e) => {
                                            *base.add(8).cast::<u8>() = (4i32) as u8;
                                            *base.add(16).cast::<f64>() = _rt::as_f64(e);
                                        }
                                        V48::Text(e) => {
                                            *base.add(8).cast::<u8>() = (5i32) as u8;
                                            let vec47 = e;
                                            let ptr47 = vec47.as_ptr().cast::<u8>();
                                            let len47 = vec47.len();
                                            *base.add(20).cast::<usize>() = len47;
                                            *base.add(16).cast::<*mut u8>() = ptr47.cast_mut();
                                        }
                                    }
                                }
                            }
                            cleanup_list
                                .extend_from_slice(&[(result44, layout44), (result49, layout49)]);

                            (
                                4i32,
                                ptr38.cast_mut(),
                                len38,
                                ptr39.cast_mut(),
                                len39 as *mut u8,
                                result44,
                                len44,
                                result49,
                                len49,
                                0i32,
                                ::core::ptr::null_mut(),
                                0usize,
                                ::core::ptr::null_mut(),
                                0usize,
                                ::core::ptr::null_mut(),
                                0usize,
                            )
                        }
                    };

                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "acts:packs/act")]
                    extern "C" {
                        #[link_name = "push"]
                        fn wit_import(
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: *mut u8,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                        );
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(
                        _: i32,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: *mut u8,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: i32,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                    ) {
                        unreachable!()
                    }
                    wit_import(
                        result51_0,
                        result51_1,
                        result51_2,
                        result51_3,
                        result51_4,
                        result51_5,
                        result51_6,
                        result51_7,
                        result51_8,
                        result51_9,
                        result51_10,
                        result51_11,
                        result51_12,
                        result51_13,
                        result51_14,
                        result51_15,
                    );
                    for (ptr, layout) in cleanup_list {
                        if layout.size() != 0 {
                            _rt::alloc::dealloc(ptr.cast(), layout);
                        }
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn push_req(req: &Request, events: &RequestEvents) {
                unsafe {
                    let mut cleanup_list = _rt::Vec::new();
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 76]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 76]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    let super::super::super::acts::packs::types::Request {
                        id: id1,
                        key: key1,
                        tag: tag1,
                        name: name1,
                        inputs: inputs1,
                        outputs: outputs1,
                    } = req;
                    let vec2 = id1;
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();
                    *ptr0.add(4).cast::<usize>() = len2;
                    *ptr0.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                    match key1 {
                        Some(e) => {
                            *ptr0.add(8).cast::<u8>() = (1i32) as u8;
                            let vec3 = e;
                            let ptr3 = vec3.as_ptr().cast::<u8>();
                            let len3 = vec3.len();
                            *ptr0.add(16).cast::<usize>() = len3;
                            *ptr0.add(12).cast::<*mut u8>() = ptr3.cast_mut();
                        }
                        None => {
                            *ptr0.add(8).cast::<u8>() = (0i32) as u8;
                        }
                    };
                    match tag1 {
                        Some(e) => {
                            *ptr0.add(20).cast::<u8>() = (1i32) as u8;
                            let vec4 = e;
                            let ptr4 = vec4.as_ptr().cast::<u8>();
                            let len4 = vec4.len();
                            *ptr0.add(28).cast::<usize>() = len4;
                            *ptr0.add(24).cast::<*mut u8>() = ptr4.cast_mut();
                        }
                        None => {
                            *ptr0.add(20).cast::<u8>() = (0i32) as u8;
                        }
                    };
                    match name1 {
                        Some(e) => {
                            *ptr0.add(32).cast::<u8>() = (1i32) as u8;
                            let vec5 = e;
                            let ptr5 = vec5.as_ptr().cast::<u8>();
                            let len5 = vec5.len();
                            *ptr0.add(40).cast::<usize>() = len5;
                            *ptr0.add(36).cast::<*mut u8>() = ptr5.cast_mut();
                        }
                        None => {
                            *ptr0.add(32).cast::<u8>() = (0i32) as u8;
                        }
                    };
                    let vec10 = inputs1;
                    let len10 = vec10.len();
                    let layout10 =
                        _rt::alloc::Layout::from_size_align_unchecked(vec10.len() * 24, 8);
                    let result10 = if layout10.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout10).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout10);
                        }
                        ptr
                    } else {
                        {
                            ::core::ptr::null_mut()
                        }
                    };
                    for (i, e) in vec10.into_iter().enumerate() {
                        let base = result10.add(i * 24);
                        {
                            let (t6_0, t6_1) = e;
                            let vec7 = t6_0;
                            let ptr7 = vec7.as_ptr().cast::<u8>();
                            let len7 = vec7.len();
                            *base.add(4).cast::<usize>() = len7;
                            *base.add(0).cast::<*mut u8>() = ptr7.cast_mut();
                            use super::super::super::acts::packs::types::Value as V9;
                            match t6_1 {
                                V9::Null => {
                                    *base.add(8).cast::<u8>() = (0i32) as u8;
                                }
                                V9::Boolean(e) => {
                                    *base.add(8).cast::<u8>() = (1i32) as u8;
                                    *base.add(16).cast::<u8>() = (match e {
                                        true => 1,
                                        false => 0,
                                    })
                                        as u8;
                                }
                                V9::PosInt(e) => {
                                    *base.add(8).cast::<u8>() = (2i32) as u8;
                                    *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                }
                                V9::NegInt(e) => {
                                    *base.add(8).cast::<u8>() = (3i32) as u8;
                                    *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                }
                                V9::Float(e) => {
                                    *base.add(8).cast::<u8>() = (4i32) as u8;
                                    *base.add(16).cast::<f64>() = _rt::as_f64(e);
                                }
                                V9::Text(e) => {
                                    *base.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec8 = e;
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    *base.add(20).cast::<usize>() = len8;
                                    *base.add(16).cast::<*mut u8>() = ptr8.cast_mut();
                                }
                            }
                        }
                    }
                    *ptr0.add(48).cast::<usize>() = len10;
                    *ptr0.add(44).cast::<*mut u8>() = result10;
                    let vec15 = outputs1;
                    let len15 = vec15.len();
                    let layout15 =
                        _rt::alloc::Layout::from_size_align_unchecked(vec15.len() * 24, 8);
                    let result15 = if layout15.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout15).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout15);
                        }
                        ptr
                    } else {
                        {
                            ::core::ptr::null_mut()
                        }
                    };
                    for (i, e) in vec15.into_iter().enumerate() {
                        let base = result15.add(i * 24);
                        {
                            let (t11_0, t11_1) = e;
                            let vec12 = t11_0;
                            let ptr12 = vec12.as_ptr().cast::<u8>();
                            let len12 = vec12.len();
                            *base.add(4).cast::<usize>() = len12;
                            *base.add(0).cast::<*mut u8>() = ptr12.cast_mut();
                            use super::super::super::acts::packs::types::Value as V14;
                            match t11_1 {
                                V14::Null => {
                                    *base.add(8).cast::<u8>() = (0i32) as u8;
                                }
                                V14::Boolean(e) => {
                                    *base.add(8).cast::<u8>() = (1i32) as u8;
                                    *base.add(16).cast::<u8>() = (match e {
                                        true => 1,
                                        false => 0,
                                    })
                                        as u8;
                                }
                                V14::PosInt(e) => {
                                    *base.add(8).cast::<u8>() = (2i32) as u8;
                                    *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                }
                                V14::NegInt(e) => {
                                    *base.add(8).cast::<u8>() = (3i32) as u8;
                                    *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                }
                                V14::Float(e) => {
                                    *base.add(8).cast::<u8>() = (4i32) as u8;
                                    *base.add(16).cast::<f64>() = _rt::as_f64(e);
                                }
                                V14::Text(e) => {
                                    *base.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec13 = e;
                                    let ptr13 = vec13.as_ptr().cast::<u8>();
                                    let len13 = vec13.len();
                                    *base.add(20).cast::<usize>() = len13;
                                    *base.add(16).cast::<*mut u8>() = ptr13.cast_mut();
                                }
                            }
                        }
                    }
                    *ptr0.add(56).cast::<usize>() = len15;
                    *ptr0.add(52).cast::<*mut u8>() = result15;
                    let super::super::super::acts::packs::types::RequestEvents {
                        on_created: on_created16,
                        on_completed: on_completed16,
                    } = events;
                    let vec62 = on_created16;
                    let len62 = vec62.len();
                    let layout62 =
                        _rt::alloc::Layout::from_size_align_unchecked(vec62.len() * 64, 4);
                    let result62 = if layout62.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout62).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout62);
                        }
                        ptr
                    } else {
                        {
                            ::core::ptr::null_mut()
                        }
                    };
                    for (i, e) in vec62.into_iter().enumerate() {
                        let base = result62.add(i * 64);
                        {
                            use super::super::super::acts::packs::types::Packet as V61;
                            match e {
                                V61::Req(e) => {
                                    *base.add(0).cast::<u8>() = (0i32) as u8;
                                    let super::super::super::acts::packs::types::Request {
                                        id: id17,
                                        key: key17,
                                        tag: tag17,
                                        name: name17,
                                        inputs: inputs17,
                                        outputs: outputs17,
                                    } = e;
                                    let vec18 = id17;
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    *base.add(8).cast::<usize>() = len18;
                                    *base.add(4).cast::<*mut u8>() = ptr18.cast_mut();
                                    match key17 {
                                        Some(e) => {
                                            *base.add(12).cast::<u8>() = (1i32) as u8;
                                            let vec19 = e;
                                            let ptr19 = vec19.as_ptr().cast::<u8>();
                                            let len19 = vec19.len();
                                            *base.add(20).cast::<usize>() = len19;
                                            *base.add(16).cast::<*mut u8>() = ptr19.cast_mut();
                                        }
                                        None => {
                                            *base.add(12).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    match tag17 {
                                        Some(e) => {
                                            *base.add(24).cast::<u8>() = (1i32) as u8;
                                            let vec20 = e;
                                            let ptr20 = vec20.as_ptr().cast::<u8>();
                                            let len20 = vec20.len();
                                            *base.add(32).cast::<usize>() = len20;
                                            *base.add(28).cast::<*mut u8>() = ptr20.cast_mut();
                                        }
                                        None => {
                                            *base.add(24).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    match name17 {
                                        Some(e) => {
                                            *base.add(36).cast::<u8>() = (1i32) as u8;
                                            let vec21 = e;
                                            let ptr21 = vec21.as_ptr().cast::<u8>();
                                            let len21 = vec21.len();
                                            *base.add(44).cast::<usize>() = len21;
                                            *base.add(40).cast::<*mut u8>() = ptr21.cast_mut();
                                        }
                                        None => {
                                            *base.add(36).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    let vec26 = inputs17;
                                    let len26 = vec26.len();
                                    let layout26 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec26.len() * 24,
                                        8,
                                    );
                                    let result26 = if layout26.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout26).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout26);
                                        }
                                        ptr
                                    } else {
                                        {
                                            ::core::ptr::null_mut()
                                        }
                                    };
                                    for (i, e) in vec26.into_iter().enumerate() {
                                        let base = result26.add(i * 24);
                                        {
                                            let (t22_0, t22_1) = e;
                                            let vec23 = t22_0;
                                            let ptr23 = vec23.as_ptr().cast::<u8>();
                                            let len23 = vec23.len();
                                            *base.add(4).cast::<usize>() = len23;
                                            *base.add(0).cast::<*mut u8>() = ptr23.cast_mut();
                                            use super::super::super::acts::packs::types::Value as V25;
                                            match t22_1 {
                                                V25::Null => {
                                                    *base.add(8).cast::<u8>() = (0i32) as u8;
                                                }
                                                V25::Boolean(e) => {
                                                    *base.add(8).cast::<u8>() = (1i32) as u8;
                                                    *base.add(16).cast::<u8>() = (match e {
                                                        true => 1,
                                                        false => 0,
                                                    })
                                                        as u8;
                                                }
                                                V25::PosInt(e) => {
                                                    *base.add(8).cast::<u8>() = (2i32) as u8;
                                                    *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                                }
                                                V25::NegInt(e) => {
                                                    *base.add(8).cast::<u8>() = (3i32) as u8;
                                                    *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                                }
                                                V25::Float(e) => {
                                                    *base.add(8).cast::<u8>() = (4i32) as u8;
                                                    *base.add(16).cast::<f64>() = _rt::as_f64(e);
                                                }
                                                V25::Text(e) => {
                                                    *base.add(8).cast::<u8>() = (5i32) as u8;
                                                    let vec24 = e;
                                                    let ptr24 = vec24.as_ptr().cast::<u8>();
                                                    let len24 = vec24.len();
                                                    *base.add(20).cast::<usize>() = len24;
                                                    *base.add(16).cast::<*mut u8>() =
                                                        ptr24.cast_mut();
                                                }
                                            }
                                        }
                                    }
                                    *base.add(52).cast::<usize>() = len26;
                                    *base.add(48).cast::<*mut u8>() = result26;
                                    let vec31 = outputs17;
                                    let len31 = vec31.len();
                                    let layout31 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec31.len() * 24,
                                        8,
                                    );
                                    let result31 = if layout31.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout31).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout31);
                                        }
                                        ptr
                                    } else {
                                        {
                                            ::core::ptr::null_mut()
                                        }
                                    };
                                    for (i, e) in vec31.into_iter().enumerate() {
                                        let base = result31.add(i * 24);
                                        {
                                            let (t27_0, t27_1) = e;
                                            let vec28 = t27_0;
                                            let ptr28 = vec28.as_ptr().cast::<u8>();
                                            let len28 = vec28.len();
                                            *base.add(4).cast::<usize>() = len28;
                                            *base.add(0).cast::<*mut u8>() = ptr28.cast_mut();
                                            use super::super::super::acts::packs::types::Value as V30;
                                            match t27_1 {
                                                V30::Null => {
                                                    *base.add(8).cast::<u8>() = (0i32) as u8;
                                                }
                                                V30::Boolean(e) => {
                                                    *base.add(8).cast::<u8>() = (1i32) as u8;
                                                    *base.add(16).cast::<u8>() = (match e {
                                                        true => 1,
                                                        false => 0,
                                                    })
                                                        as u8;
                                                }
                                                V30::PosInt(e) => {
                                                    *base.add(8).cast::<u8>() = (2i32) as u8;
                                                    *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                                }
                                                V30::NegInt(e) => {
                                                    *base.add(8).cast::<u8>() = (3i32) as u8;
                                                    *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                                }
                                                V30::Float(e) => {
                                                    *base.add(8).cast::<u8>() = (4i32) as u8;
                                                    *base.add(16).cast::<f64>() = _rt::as_f64(e);
                                                }
                                                V30::Text(e) => {
                                                    *base.add(8).cast::<u8>() = (5i32) as u8;
                                                    let vec29 = e;
                                                    let ptr29 = vec29.as_ptr().cast::<u8>();
                                                    let len29 = vec29.len();
                                                    *base.add(20).cast::<usize>() = len29;
                                                    *base.add(16).cast::<*mut u8>() =
                                                        ptr29.cast_mut();
                                                }
                                            }
                                        }
                                    }
                                    *base.add(60).cast::<usize>() = len31;
                                    *base.add(56).cast::<*mut u8>() = result31;
                                    cleanup_list.extend_from_slice(&[
                                        (result26, layout26),
                                        (result31, layout31),
                                    ]);
                                }
                                V61::Msg(e) => {
                                    *base.add(0).cast::<u8>() = (1i32) as u8;
                                    let super::super::super::acts::packs::types::Message {
                                        id: id32,
                                        key: key32,
                                        tag: tag32,
                                        name: name32,
                                        inputs: inputs32,
                                    } = e;
                                    let vec33 = id32;
                                    let ptr33 = vec33.as_ptr().cast::<u8>();
                                    let len33 = vec33.len();
                                    *base.add(8).cast::<usize>() = len33;
                                    *base.add(4).cast::<*mut u8>() = ptr33.cast_mut();
                                    match key32 {
                                        Some(e) => {
                                            *base.add(12).cast::<u8>() = (1i32) as u8;
                                            let vec34 = e;
                                            let ptr34 = vec34.as_ptr().cast::<u8>();
                                            let len34 = vec34.len();
                                            *base.add(20).cast::<usize>() = len34;
                                            *base.add(16).cast::<*mut u8>() = ptr34.cast_mut();
                                        }
                                        None => {
                                            *base.add(12).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    match tag32 {
                                        Some(e) => {
                                            *base.add(24).cast::<u8>() = (1i32) as u8;
                                            let vec35 = e;
                                            let ptr35 = vec35.as_ptr().cast::<u8>();
                                            let len35 = vec35.len();
                                            *base.add(32).cast::<usize>() = len35;
                                            *base.add(28).cast::<*mut u8>() = ptr35.cast_mut();
                                        }
                                        None => {
                                            *base.add(24).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    match name32 {
                                        Some(e) => {
                                            *base.add(36).cast::<u8>() = (1i32) as u8;
                                            let vec36 = e;
                                            let ptr36 = vec36.as_ptr().cast::<u8>();
                                            let len36 = vec36.len();
                                            *base.add(44).cast::<usize>() = len36;
                                            *base.add(40).cast::<*mut u8>() = ptr36.cast_mut();
                                        }
                                        None => {
                                            *base.add(36).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    let vec41 = inputs32;
                                    let len41 = vec41.len();
                                    let layout41 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec41.len() * 24,
                                        8,
                                    );
                                    let result41 = if layout41.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout41).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout41);
                                        }
                                        ptr
                                    } else {
                                        {
                                            ::core::ptr::null_mut()
                                        }
                                    };
                                    for (i, e) in vec41.into_iter().enumerate() {
                                        let base = result41.add(i * 24);
                                        {
                                            let (t37_0, t37_1) = e;
                                            let vec38 = t37_0;
                                            let ptr38 = vec38.as_ptr().cast::<u8>();
                                            let len38 = vec38.len();
                                            *base.add(4).cast::<usize>() = len38;
                                            *base.add(0).cast::<*mut u8>() = ptr38.cast_mut();
                                            use super::super::super::acts::packs::types::Value as V40;
                                            match t37_1 {
                                                V40::Null => {
                                                    *base.add(8).cast::<u8>() = (0i32) as u8;
                                                }
                                                V40::Boolean(e) => {
                                                    *base.add(8).cast::<u8>() = (1i32) as u8;
                                                    *base.add(16).cast::<u8>() = (match e {
                                                        true => 1,
                                                        false => 0,
                                                    })
                                                        as u8;
                                                }
                                                V40::PosInt(e) => {
                                                    *base.add(8).cast::<u8>() = (2i32) as u8;
                                                    *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                                }
                                                V40::NegInt(e) => {
                                                    *base.add(8).cast::<u8>() = (3i32) as u8;
                                                    *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                                }
                                                V40::Float(e) => {
                                                    *base.add(8).cast::<u8>() = (4i32) as u8;
                                                    *base.add(16).cast::<f64>() = _rt::as_f64(e);
                                                }
                                                V40::Text(e) => {
                                                    *base.add(8).cast::<u8>() = (5i32) as u8;
                                                    let vec39 = e;
                                                    let ptr39 = vec39.as_ptr().cast::<u8>();
                                                    let len39 = vec39.len();
                                                    *base.add(20).cast::<usize>() = len39;
                                                    *base.add(16).cast::<*mut u8>() =
                                                        ptr39.cast_mut();
                                                }
                                            }
                                        }
                                    }
                                    *base.add(52).cast::<usize>() = len41;
                                    *base.add(48).cast::<*mut u8>() = result41;
                                    cleanup_list.extend_from_slice(&[(result41, layout41)]);
                                }
                                V61::Chain(e) => {
                                    *base.add(0).cast::<u8>() = (2i32) as u8;
                                    let super::super::super::acts::packs::types::Chain {
                                        ins: ins42,
                                    } = e;
                                    let vec44 = ins42;
                                    let len44 = vec44.len();
                                    let layout44 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec44.len() * 8,
                                        4,
                                    );
                                    let result44 = if layout44.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout44).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout44);
                                        }
                                        ptr
                                    } else {
                                        {
                                            ::core::ptr::null_mut()
                                        }
                                    };
                                    for (i, e) in vec44.into_iter().enumerate() {
                                        let base = result44.add(i * 8);
                                        {
                                            let vec43 = e;
                                            let ptr43 = vec43.as_ptr().cast::<u8>();
                                            let len43 = vec43.len();
                                            *base.add(4).cast::<usize>() = len43;
                                            *base.add(0).cast::<*mut u8>() = ptr43.cast_mut();
                                        }
                                    }
                                    *base.add(8).cast::<usize>() = len44;
                                    *base.add(4).cast::<*mut u8>() = result44;
                                    cleanup_list.extend_from_slice(&[(result44, layout44)]);
                                }
                                V61::Each(e) => {
                                    *base.add(0).cast::<u8>() = (3i32) as u8;
                                    let super::super::super::acts::packs::types::Each {
                                        ins: ins45,
                                    } = e;
                                    let vec47 = ins45;
                                    let len47 = vec47.len();
                                    let layout47 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec47.len() * 8,
                                        4,
                                    );
                                    let result47 = if layout47.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout47).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout47);
                                        }
                                        ptr
                                    } else {
                                        {
                                            ::core::ptr::null_mut()
                                        }
                                    };
                                    for (i, e) in vec47.into_iter().enumerate() {
                                        let base = result47.add(i * 8);
                                        {
                                            let vec46 = e;
                                            let ptr46 = vec46.as_ptr().cast::<u8>();
                                            let len46 = vec46.len();
                                            *base.add(4).cast::<usize>() = len46;
                                            *base.add(0).cast::<*mut u8>() = ptr46.cast_mut();
                                        }
                                    }
                                    *base.add(8).cast::<usize>() = len47;
                                    *base.add(4).cast::<*mut u8>() = result47;
                                    cleanup_list.extend_from_slice(&[(result47, layout47)]);
                                }
                                V61::Call(e) => {
                                    *base.add(0).cast::<u8>() = (4i32) as u8;
                                    let super::super::super::acts::packs::types::Call {
                                        id: id48,
                                        mid: mid48,
                                        inputs: inputs48,
                                        outputs: outputs48,
                                    } = e;
                                    let vec49 = id48;
                                    let ptr49 = vec49.as_ptr().cast::<u8>();
                                    let len49 = vec49.len();
                                    *base.add(8).cast::<usize>() = len49;
                                    *base.add(4).cast::<*mut u8>() = ptr49.cast_mut();
                                    let vec50 = mid48;
                                    let ptr50 = vec50.as_ptr().cast::<u8>();
                                    let len50 = vec50.len();
                                    *base.add(16).cast::<usize>() = len50;
                                    *base.add(12).cast::<*mut u8>() = ptr50.cast_mut();
                                    let vec55 = inputs48;
                                    let len55 = vec55.len();
                                    let layout55 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec55.len() * 24,
                                        8,
                                    );
                                    let result55 = if layout55.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout55).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout55);
                                        }
                                        ptr
                                    } else {
                                        {
                                            ::core::ptr::null_mut()
                                        }
                                    };
                                    for (i, e) in vec55.into_iter().enumerate() {
                                        let base = result55.add(i * 24);
                                        {
                                            let (t51_0, t51_1) = e;
                                            let vec52 = t51_0;
                                            let ptr52 = vec52.as_ptr().cast::<u8>();
                                            let len52 = vec52.len();
                                            *base.add(4).cast::<usize>() = len52;
                                            *base.add(0).cast::<*mut u8>() = ptr52.cast_mut();
                                            use super::super::super::acts::packs::types::Value as V54;
                                            match t51_1 {
                                                V54::Null => {
                                                    *base.add(8).cast::<u8>() = (0i32) as u8;
                                                }
                                                V54::Boolean(e) => {
                                                    *base.add(8).cast::<u8>() = (1i32) as u8;
                                                    *base.add(16).cast::<u8>() = (match e {
                                                        true => 1,
                                                        false => 0,
                                                    })
                                                        as u8;
                                                }
                                                V54::PosInt(e) => {
                                                    *base.add(8).cast::<u8>() = (2i32) as u8;
                                                    *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                                }
                                                V54::NegInt(e) => {
                                                    *base.add(8).cast::<u8>() = (3i32) as u8;
                                                    *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                                }
                                                V54::Float(e) => {
                                                    *base.add(8).cast::<u8>() = (4i32) as u8;
                                                    *base.add(16).cast::<f64>() = _rt::as_f64(e);
                                                }
                                                V54::Text(e) => {
                                                    *base.add(8).cast::<u8>() = (5i32) as u8;
                                                    let vec53 = e;
                                                    let ptr53 = vec53.as_ptr().cast::<u8>();
                                                    let len53 = vec53.len();
                                                    *base.add(20).cast::<usize>() = len53;
                                                    *base.add(16).cast::<*mut u8>() =
                                                        ptr53.cast_mut();
                                                }
                                            }
                                        }
                                    }
                                    *base.add(24).cast::<usize>() = len55;
                                    *base.add(20).cast::<*mut u8>() = result55;
                                    let vec60 = outputs48;
                                    let len60 = vec60.len();
                                    let layout60 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec60.len() * 24,
                                        8,
                                    );
                                    let result60 = if layout60.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout60).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout60);
                                        }
                                        ptr
                                    } else {
                                        {
                                            ::core::ptr::null_mut()
                                        }
                                    };
                                    for (i, e) in vec60.into_iter().enumerate() {
                                        let base = result60.add(i * 24);
                                        {
                                            let (t56_0, t56_1) = e;
                                            let vec57 = t56_0;
                                            let ptr57 = vec57.as_ptr().cast::<u8>();
                                            let len57 = vec57.len();
                                            *base.add(4).cast::<usize>() = len57;
                                            *base.add(0).cast::<*mut u8>() = ptr57.cast_mut();
                                            use super::super::super::acts::packs::types::Value as V59;
                                            match t56_1 {
                                                V59::Null => {
                                                    *base.add(8).cast::<u8>() = (0i32) as u8;
                                                }
                                                V59::Boolean(e) => {
                                                    *base.add(8).cast::<u8>() = (1i32) as u8;
                                                    *base.add(16).cast::<u8>() = (match e {
                                                        true => 1,
                                                        false => 0,
                                                    })
                                                        as u8;
                                                }
                                                V59::PosInt(e) => {
                                                    *base.add(8).cast::<u8>() = (2i32) as u8;
                                                    *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                                }
                                                V59::NegInt(e) => {
                                                    *base.add(8).cast::<u8>() = (3i32) as u8;
                                                    *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                                }
                                                V59::Float(e) => {
                                                    *base.add(8).cast::<u8>() = (4i32) as u8;
                                                    *base.add(16).cast::<f64>() = _rt::as_f64(e);
                                                }
                                                V59::Text(e) => {
                                                    *base.add(8).cast::<u8>() = (5i32) as u8;
                                                    let vec58 = e;
                                                    let ptr58 = vec58.as_ptr().cast::<u8>();
                                                    let len58 = vec58.len();
                                                    *base.add(20).cast::<usize>() = len58;
                                                    *base.add(16).cast::<*mut u8>() =
                                                        ptr58.cast_mut();
                                                }
                                            }
                                        }
                                    }
                                    *base.add(32).cast::<usize>() = len60;
                                    *base.add(28).cast::<*mut u8>() = result60;
                                    cleanup_list.extend_from_slice(&[
                                        (result55, layout55),
                                        (result60, layout60),
                                    ]);
                                }
                            }
                        }
                    }
                    *ptr0.add(64).cast::<usize>() = len62;
                    *ptr0.add(60).cast::<*mut u8>() = result62;
                    let vec108 = on_completed16;
                    let len108 = vec108.len();
                    let layout108 =
                        _rt::alloc::Layout::from_size_align_unchecked(vec108.len() * 64, 4);
                    let result108 = if layout108.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout108).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout108);
                        }
                        ptr
                    } else {
                        {
                            ::core::ptr::null_mut()
                        }
                    };
                    for (i, e) in vec108.into_iter().enumerate() {
                        let base = result108.add(i * 64);
                        {
                            use super::super::super::acts::packs::types::Packet as V107;
                            match e {
                                V107::Req(e) => {
                                    *base.add(0).cast::<u8>() = (0i32) as u8;
                                    let super::super::super::acts::packs::types::Request {
                                        id: id63,
                                        key: key63,
                                        tag: tag63,
                                        name: name63,
                                        inputs: inputs63,
                                        outputs: outputs63,
                                    } = e;
                                    let vec64 = id63;
                                    let ptr64 = vec64.as_ptr().cast::<u8>();
                                    let len64 = vec64.len();
                                    *base.add(8).cast::<usize>() = len64;
                                    *base.add(4).cast::<*mut u8>() = ptr64.cast_mut();
                                    match key63 {
                                        Some(e) => {
                                            *base.add(12).cast::<u8>() = (1i32) as u8;
                                            let vec65 = e;
                                            let ptr65 = vec65.as_ptr().cast::<u8>();
                                            let len65 = vec65.len();
                                            *base.add(20).cast::<usize>() = len65;
                                            *base.add(16).cast::<*mut u8>() = ptr65.cast_mut();
                                        }
                                        None => {
                                            *base.add(12).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    match tag63 {
                                        Some(e) => {
                                            *base.add(24).cast::<u8>() = (1i32) as u8;
                                            let vec66 = e;
                                            let ptr66 = vec66.as_ptr().cast::<u8>();
                                            let len66 = vec66.len();
                                            *base.add(32).cast::<usize>() = len66;
                                            *base.add(28).cast::<*mut u8>() = ptr66.cast_mut();
                                        }
                                        None => {
                                            *base.add(24).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    match name63 {
                                        Some(e) => {
                                            *base.add(36).cast::<u8>() = (1i32) as u8;
                                            let vec67 = e;
                                            let ptr67 = vec67.as_ptr().cast::<u8>();
                                            let len67 = vec67.len();
                                            *base.add(44).cast::<usize>() = len67;
                                            *base.add(40).cast::<*mut u8>() = ptr67.cast_mut();
                                        }
                                        None => {
                                            *base.add(36).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    let vec72 = inputs63;
                                    let len72 = vec72.len();
                                    let layout72 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec72.len() * 24,
                                        8,
                                    );
                                    let result72 = if layout72.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout72).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout72);
                                        }
                                        ptr
                                    } else {
                                        {
                                            ::core::ptr::null_mut()
                                        }
                                    };
                                    for (i, e) in vec72.into_iter().enumerate() {
                                        let base = result72.add(i * 24);
                                        {
                                            let (t68_0, t68_1) = e;
                                            let vec69 = t68_0;
                                            let ptr69 = vec69.as_ptr().cast::<u8>();
                                            let len69 = vec69.len();
                                            *base.add(4).cast::<usize>() = len69;
                                            *base.add(0).cast::<*mut u8>() = ptr69.cast_mut();
                                            use super::super::super::acts::packs::types::Value as V71;
                                            match t68_1 {
                                                V71::Null => {
                                                    *base.add(8).cast::<u8>() = (0i32) as u8;
                                                }
                                                V71::Boolean(e) => {
                                                    *base.add(8).cast::<u8>() = (1i32) as u8;
                                                    *base.add(16).cast::<u8>() = (match e {
                                                        true => 1,
                                                        false => 0,
                                                    })
                                                        as u8;
                                                }
                                                V71::PosInt(e) => {
                                                    *base.add(8).cast::<u8>() = (2i32) as u8;
                                                    *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                                }
                                                V71::NegInt(e) => {
                                                    *base.add(8).cast::<u8>() = (3i32) as u8;
                                                    *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                                }
                                                V71::Float(e) => {
                                                    *base.add(8).cast::<u8>() = (4i32) as u8;
                                                    *base.add(16).cast::<f64>() = _rt::as_f64(e);
                                                }
                                                V71::Text(e) => {
                                                    *base.add(8).cast::<u8>() = (5i32) as u8;
                                                    let vec70 = e;
                                                    let ptr70 = vec70.as_ptr().cast::<u8>();
                                                    let len70 = vec70.len();
                                                    *base.add(20).cast::<usize>() = len70;
                                                    *base.add(16).cast::<*mut u8>() =
                                                        ptr70.cast_mut();
                                                }
                                            }
                                        }
                                    }
                                    *base.add(52).cast::<usize>() = len72;
                                    *base.add(48).cast::<*mut u8>() = result72;
                                    let vec77 = outputs63;
                                    let len77 = vec77.len();
                                    let layout77 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec77.len() * 24,
                                        8,
                                    );
                                    let result77 = if layout77.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout77).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout77);
                                        }
                                        ptr
                                    } else {
                                        {
                                            ::core::ptr::null_mut()
                                        }
                                    };
                                    for (i, e) in vec77.into_iter().enumerate() {
                                        let base = result77.add(i * 24);
                                        {
                                            let (t73_0, t73_1) = e;
                                            let vec74 = t73_0;
                                            let ptr74 = vec74.as_ptr().cast::<u8>();
                                            let len74 = vec74.len();
                                            *base.add(4).cast::<usize>() = len74;
                                            *base.add(0).cast::<*mut u8>() = ptr74.cast_mut();
                                            use super::super::super::acts::packs::types::Value as V76;
                                            match t73_1 {
                                                V76::Null => {
                                                    *base.add(8).cast::<u8>() = (0i32) as u8;
                                                }
                                                V76::Boolean(e) => {
                                                    *base.add(8).cast::<u8>() = (1i32) as u8;
                                                    *base.add(16).cast::<u8>() = (match e {
                                                        true => 1,
                                                        false => 0,
                                                    })
                                                        as u8;
                                                }
                                                V76::PosInt(e) => {
                                                    *base.add(8).cast::<u8>() = (2i32) as u8;
                                                    *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                                }
                                                V76::NegInt(e) => {
                                                    *base.add(8).cast::<u8>() = (3i32) as u8;
                                                    *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                                }
                                                V76::Float(e) => {
                                                    *base.add(8).cast::<u8>() = (4i32) as u8;
                                                    *base.add(16).cast::<f64>() = _rt::as_f64(e);
                                                }
                                                V76::Text(e) => {
                                                    *base.add(8).cast::<u8>() = (5i32) as u8;
                                                    let vec75 = e;
                                                    let ptr75 = vec75.as_ptr().cast::<u8>();
                                                    let len75 = vec75.len();
                                                    *base.add(20).cast::<usize>() = len75;
                                                    *base.add(16).cast::<*mut u8>() =
                                                        ptr75.cast_mut();
                                                }
                                            }
                                        }
                                    }
                                    *base.add(60).cast::<usize>() = len77;
                                    *base.add(56).cast::<*mut u8>() = result77;
                                    cleanup_list.extend_from_slice(&[
                                        (result72, layout72),
                                        (result77, layout77),
                                    ]);
                                }
                                V107::Msg(e) => {
                                    *base.add(0).cast::<u8>() = (1i32) as u8;
                                    let super::super::super::acts::packs::types::Message {
                                        id: id78,
                                        key: key78,
                                        tag: tag78,
                                        name: name78,
                                        inputs: inputs78,
                                    } = e;
                                    let vec79 = id78;
                                    let ptr79 = vec79.as_ptr().cast::<u8>();
                                    let len79 = vec79.len();
                                    *base.add(8).cast::<usize>() = len79;
                                    *base.add(4).cast::<*mut u8>() = ptr79.cast_mut();
                                    match key78 {
                                        Some(e) => {
                                            *base.add(12).cast::<u8>() = (1i32) as u8;
                                            let vec80 = e;
                                            let ptr80 = vec80.as_ptr().cast::<u8>();
                                            let len80 = vec80.len();
                                            *base.add(20).cast::<usize>() = len80;
                                            *base.add(16).cast::<*mut u8>() = ptr80.cast_mut();
                                        }
                                        None => {
                                            *base.add(12).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    match tag78 {
                                        Some(e) => {
                                            *base.add(24).cast::<u8>() = (1i32) as u8;
                                            let vec81 = e;
                                            let ptr81 = vec81.as_ptr().cast::<u8>();
                                            let len81 = vec81.len();
                                            *base.add(32).cast::<usize>() = len81;
                                            *base.add(28).cast::<*mut u8>() = ptr81.cast_mut();
                                        }
                                        None => {
                                            *base.add(24).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    match name78 {
                                        Some(e) => {
                                            *base.add(36).cast::<u8>() = (1i32) as u8;
                                            let vec82 = e;
                                            let ptr82 = vec82.as_ptr().cast::<u8>();
                                            let len82 = vec82.len();
                                            *base.add(44).cast::<usize>() = len82;
                                            *base.add(40).cast::<*mut u8>() = ptr82.cast_mut();
                                        }
                                        None => {
                                            *base.add(36).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    let vec87 = inputs78;
                                    let len87 = vec87.len();
                                    let layout87 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec87.len() * 24,
                                        8,
                                    );
                                    let result87 = if layout87.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout87).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout87);
                                        }
                                        ptr
                                    } else {
                                        {
                                            ::core::ptr::null_mut()
                                        }
                                    };
                                    for (i, e) in vec87.into_iter().enumerate() {
                                        let base = result87.add(i * 24);
                                        {
                                            let (t83_0, t83_1) = e;
                                            let vec84 = t83_0;
                                            let ptr84 = vec84.as_ptr().cast::<u8>();
                                            let len84 = vec84.len();
                                            *base.add(4).cast::<usize>() = len84;
                                            *base.add(0).cast::<*mut u8>() = ptr84.cast_mut();
                                            use super::super::super::acts::packs::types::Value as V86;
                                            match t83_1 {
                                                V86::Null => {
                                                    *base.add(8).cast::<u8>() = (0i32) as u8;
                                                }
                                                V86::Boolean(e) => {
                                                    *base.add(8).cast::<u8>() = (1i32) as u8;
                                                    *base.add(16).cast::<u8>() = (match e {
                                                        true => 1,
                                                        false => 0,
                                                    })
                                                        as u8;
                                                }
                                                V86::PosInt(e) => {
                                                    *base.add(8).cast::<u8>() = (2i32) as u8;
                                                    *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                                }
                                                V86::NegInt(e) => {
                                                    *base.add(8).cast::<u8>() = (3i32) as u8;
                                                    *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                                }
                                                V86::Float(e) => {
                                                    *base.add(8).cast::<u8>() = (4i32) as u8;
                                                    *base.add(16).cast::<f64>() = _rt::as_f64(e);
                                                }
                                                V86::Text(e) => {
                                                    *base.add(8).cast::<u8>() = (5i32) as u8;
                                                    let vec85 = e;
                                                    let ptr85 = vec85.as_ptr().cast::<u8>();
                                                    let len85 = vec85.len();
                                                    *base.add(20).cast::<usize>() = len85;
                                                    *base.add(16).cast::<*mut u8>() =
                                                        ptr85.cast_mut();
                                                }
                                            }
                                        }
                                    }
                                    *base.add(52).cast::<usize>() = len87;
                                    *base.add(48).cast::<*mut u8>() = result87;
                                    cleanup_list.extend_from_slice(&[(result87, layout87)]);
                                }
                                V107::Chain(e) => {
                                    *base.add(0).cast::<u8>() = (2i32) as u8;
                                    let super::super::super::acts::packs::types::Chain {
                                        ins: ins88,
                                    } = e;
                                    let vec90 = ins88;
                                    let len90 = vec90.len();
                                    let layout90 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec90.len() * 8,
                                        4,
                                    );
                                    let result90 = if layout90.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout90).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout90);
                                        }
                                        ptr
                                    } else {
                                        {
                                            ::core::ptr::null_mut()
                                        }
                                    };
                                    for (i, e) in vec90.into_iter().enumerate() {
                                        let base = result90.add(i * 8);
                                        {
                                            let vec89 = e;
                                            let ptr89 = vec89.as_ptr().cast::<u8>();
                                            let len89 = vec89.len();
                                            *base.add(4).cast::<usize>() = len89;
                                            *base.add(0).cast::<*mut u8>() = ptr89.cast_mut();
                                        }
                                    }
                                    *base.add(8).cast::<usize>() = len90;
                                    *base.add(4).cast::<*mut u8>() = result90;
                                    cleanup_list.extend_from_slice(&[(result90, layout90)]);
                                }
                                V107::Each(e) => {
                                    *base.add(0).cast::<u8>() = (3i32) as u8;
                                    let super::super::super::acts::packs::types::Each {
                                        ins: ins91,
                                    } = e;
                                    let vec93 = ins91;
                                    let len93 = vec93.len();
                                    let layout93 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec93.len() * 8,
                                        4,
                                    );
                                    let result93 = if layout93.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout93).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout93);
                                        }
                                        ptr
                                    } else {
                                        {
                                            ::core::ptr::null_mut()
                                        }
                                    };
                                    for (i, e) in vec93.into_iter().enumerate() {
                                        let base = result93.add(i * 8);
                                        {
                                            let vec92 = e;
                                            let ptr92 = vec92.as_ptr().cast::<u8>();
                                            let len92 = vec92.len();
                                            *base.add(4).cast::<usize>() = len92;
                                            *base.add(0).cast::<*mut u8>() = ptr92.cast_mut();
                                        }
                                    }
                                    *base.add(8).cast::<usize>() = len93;
                                    *base.add(4).cast::<*mut u8>() = result93;
                                    cleanup_list.extend_from_slice(&[(result93, layout93)]);
                                }
                                V107::Call(e) => {
                                    *base.add(0).cast::<u8>() = (4i32) as u8;
                                    let super::super::super::acts::packs::types::Call {
                                        id: id94,
                                        mid: mid94,
                                        inputs: inputs94,
                                        outputs: outputs94,
                                    } = e;
                                    let vec95 = id94;
                                    let ptr95 = vec95.as_ptr().cast::<u8>();
                                    let len95 = vec95.len();
                                    *base.add(8).cast::<usize>() = len95;
                                    *base.add(4).cast::<*mut u8>() = ptr95.cast_mut();
                                    let vec96 = mid94;
                                    let ptr96 = vec96.as_ptr().cast::<u8>();
                                    let len96 = vec96.len();
                                    *base.add(16).cast::<usize>() = len96;
                                    *base.add(12).cast::<*mut u8>() = ptr96.cast_mut();
                                    let vec101 = inputs94;
                                    let len101 = vec101.len();
                                    let layout101 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec101.len() * 24,
                                        8,
                                    );
                                    let result101 = if layout101.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout101).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout101);
                                        }
                                        ptr
                                    } else {
                                        {
                                            ::core::ptr::null_mut()
                                        }
                                    };
                                    for (i, e) in vec101.into_iter().enumerate() {
                                        let base = result101.add(i * 24);
                                        {
                                            let (t97_0, t97_1) = e;
                                            let vec98 = t97_0;
                                            let ptr98 = vec98.as_ptr().cast::<u8>();
                                            let len98 = vec98.len();
                                            *base.add(4).cast::<usize>() = len98;
                                            *base.add(0).cast::<*mut u8>() = ptr98.cast_mut();
                                            use super::super::super::acts::packs::types::Value as V100;
                                            match t97_1 {
                                                V100::Null => {
                                                    *base.add(8).cast::<u8>() = (0i32) as u8;
                                                }
                                                V100::Boolean(e) => {
                                                    *base.add(8).cast::<u8>() = (1i32) as u8;
                                                    *base.add(16).cast::<u8>() = (match e {
                                                        true => 1,
                                                        false => 0,
                                                    })
                                                        as u8;
                                                }
                                                V100::PosInt(e) => {
                                                    *base.add(8).cast::<u8>() = (2i32) as u8;
                                                    *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                                }
                                                V100::NegInt(e) => {
                                                    *base.add(8).cast::<u8>() = (3i32) as u8;
                                                    *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                                }
                                                V100::Float(e) => {
                                                    *base.add(8).cast::<u8>() = (4i32) as u8;
                                                    *base.add(16).cast::<f64>() = _rt::as_f64(e);
                                                }
                                                V100::Text(e) => {
                                                    *base.add(8).cast::<u8>() = (5i32) as u8;
                                                    let vec99 = e;
                                                    let ptr99 = vec99.as_ptr().cast::<u8>();
                                                    let len99 = vec99.len();
                                                    *base.add(20).cast::<usize>() = len99;
                                                    *base.add(16).cast::<*mut u8>() =
                                                        ptr99.cast_mut();
                                                }
                                            }
                                        }
                                    }
                                    *base.add(24).cast::<usize>() = len101;
                                    *base.add(20).cast::<*mut u8>() = result101;
                                    let vec106 = outputs94;
                                    let len106 = vec106.len();
                                    let layout106 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec106.len() * 24,
                                        8,
                                    );
                                    let result106 = if layout106.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout106).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout106);
                                        }
                                        ptr
                                    } else {
                                        {
                                            ::core::ptr::null_mut()
                                        }
                                    };
                                    for (i, e) in vec106.into_iter().enumerate() {
                                        let base = result106.add(i * 24);
                                        {
                                            let (t102_0, t102_1) = e;
                                            let vec103 = t102_0;
                                            let ptr103 = vec103.as_ptr().cast::<u8>();
                                            let len103 = vec103.len();
                                            *base.add(4).cast::<usize>() = len103;
                                            *base.add(0).cast::<*mut u8>() = ptr103.cast_mut();
                                            use super::super::super::acts::packs::types::Value as V105;
                                            match t102_1 {
                                                V105::Null => {
                                                    *base.add(8).cast::<u8>() = (0i32) as u8;
                                                }
                                                V105::Boolean(e) => {
                                                    *base.add(8).cast::<u8>() = (1i32) as u8;
                                                    *base.add(16).cast::<u8>() = (match e {
                                                        true => 1,
                                                        false => 0,
                                                    })
                                                        as u8;
                                                }
                                                V105::PosInt(e) => {
                                                    *base.add(8).cast::<u8>() = (2i32) as u8;
                                                    *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                                }
                                                V105::NegInt(e) => {
                                                    *base.add(8).cast::<u8>() = (3i32) as u8;
                                                    *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                                }
                                                V105::Float(e) => {
                                                    *base.add(8).cast::<u8>() = (4i32) as u8;
                                                    *base.add(16).cast::<f64>() = _rt::as_f64(e);
                                                }
                                                V105::Text(e) => {
                                                    *base.add(8).cast::<u8>() = (5i32) as u8;
                                                    let vec104 = e;
                                                    let ptr104 = vec104.as_ptr().cast::<u8>();
                                                    let len104 = vec104.len();
                                                    *base.add(20).cast::<usize>() = len104;
                                                    *base.add(16).cast::<*mut u8>() =
                                                        ptr104.cast_mut();
                                                }
                                            }
                                        }
                                    }
                                    *base.add(32).cast::<usize>() = len106;
                                    *base.add(28).cast::<*mut u8>() = result106;
                                    cleanup_list.extend_from_slice(&[
                                        (result101, layout101),
                                        (result106, layout106),
                                    ]);
                                }
                            }
                        }
                    }
                    *ptr0.add(72).cast::<usize>() = len108;
                    *ptr0.add(68).cast::<*mut u8>() = result108;

                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "acts:packs/act")]
                    extern "C" {
                        #[link_name = "push-req"]
                        fn wit_import(_: *mut u8);
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8) {
                        unreachable!()
                    }
                    wit_import(ptr0);
                    if layout10.size() != 0 {
                        _rt::alloc::dealloc(result10.cast(), layout10);
                    }
                    if layout15.size() != 0 {
                        _rt::alloc::dealloc(result15.cast(), layout15);
                    }
                    if layout62.size() != 0 {
                        _rt::alloc::dealloc(result62.cast(), layout62);
                    }
                    if layout108.size() != 0 {
                        _rt::alloc::dealloc(result108.cast(), layout108);
                    }
                    for (ptr, layout) in cleanup_list {
                        if layout.size() != 0 {
                            _rt::alloc::dealloc(ptr.cast(), layout);
                        }
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn push_msg(chain: &Message) {
                unsafe {
                    let super::super::super::acts::packs::types::Message {
                        id: id0,
                        key: key0,
                        tag: tag0,
                        name: name0,
                        inputs: inputs0,
                    } = chain;
                    let vec1 = id0;
                    let ptr1 = vec1.as_ptr().cast::<u8>();
                    let len1 = vec1.len();
                    let (result3_0, result3_1, result3_2) = match key0 {
                        Some(e) => {
                            let vec2 = e;
                            let ptr2 = vec2.as_ptr().cast::<u8>();
                            let len2 = vec2.len();

                            (1i32, ptr2.cast_mut(), len2)
                        }
                        None => (0i32, ::core::ptr::null_mut(), 0usize),
                    };
                    let (result5_0, result5_1, result5_2) = match tag0 {
                        Some(e) => {
                            let vec4 = e;
                            let ptr4 = vec4.as_ptr().cast::<u8>();
                            let len4 = vec4.len();

                            (1i32, ptr4.cast_mut(), len4)
                        }
                        None => (0i32, ::core::ptr::null_mut(), 0usize),
                    };
                    let (result7_0, result7_1, result7_2) = match name0 {
                        Some(e) => {
                            let vec6 = e;
                            let ptr6 = vec6.as_ptr().cast::<u8>();
                            let len6 = vec6.len();

                            (1i32, ptr6.cast_mut(), len6)
                        }
                        None => (0i32, ::core::ptr::null_mut(), 0usize),
                    };
                    let vec12 = inputs0;
                    let len12 = vec12.len();
                    let layout12 =
                        _rt::alloc::Layout::from_size_align_unchecked(vec12.len() * 24, 8);
                    let result12 = if layout12.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout12).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout12);
                        }
                        ptr
                    } else {
                        {
                            ::core::ptr::null_mut()
                        }
                    };
                    for (i, e) in vec12.into_iter().enumerate() {
                        let base = result12.add(i * 24);
                        {
                            let (t8_0, t8_1) = e;
                            let vec9 = t8_0;
                            let ptr9 = vec9.as_ptr().cast::<u8>();
                            let len9 = vec9.len();
                            *base.add(4).cast::<usize>() = len9;
                            *base.add(0).cast::<*mut u8>() = ptr9.cast_mut();
                            use super::super::super::acts::packs::types::Value as V11;
                            match t8_1 {
                                V11::Null => {
                                    *base.add(8).cast::<u8>() = (0i32) as u8;
                                }
                                V11::Boolean(e) => {
                                    *base.add(8).cast::<u8>() = (1i32) as u8;
                                    *base.add(16).cast::<u8>() = (match e {
                                        true => 1,
                                        false => 0,
                                    })
                                        as u8;
                                }
                                V11::PosInt(e) => {
                                    *base.add(8).cast::<u8>() = (2i32) as u8;
                                    *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                }
                                V11::NegInt(e) => {
                                    *base.add(8).cast::<u8>() = (3i32) as u8;
                                    *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                }
                                V11::Float(e) => {
                                    *base.add(8).cast::<u8>() = (4i32) as u8;
                                    *base.add(16).cast::<f64>() = _rt::as_f64(e);
                                }
                                V11::Text(e) => {
                                    *base.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec10 = e;
                                    let ptr10 = vec10.as_ptr().cast::<u8>();
                                    let len10 = vec10.len();
                                    *base.add(20).cast::<usize>() = len10;
                                    *base.add(16).cast::<*mut u8>() = ptr10.cast_mut();
                                }
                            }
                        }
                    }

                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "acts:packs/act")]
                    extern "C" {
                        #[link_name = "push-msg"]
                        fn wit_import(
                            _: *mut u8,
                            _: usize,
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                        );
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(
                        _: *mut u8,
                        _: usize,
                        _: i32,
                        _: *mut u8,
                        _: usize,
                        _: i32,
                        _: *mut u8,
                        _: usize,
                        _: i32,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                    ) {
                        unreachable!()
                    }
                    wit_import(
                        ptr1.cast_mut(),
                        len1,
                        result3_0,
                        result3_1,
                        result3_2,
                        result5_0,
                        result5_1,
                        result5_2,
                        result7_0,
                        result7_1,
                        result7_2,
                        result12,
                        len12,
                    );
                    if layout12.size() != 0 {
                        _rt::alloc::dealloc(result12.cast(), layout12);
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn push_chain(chain: &Chain) {
                unsafe {
                    let super::super::super::acts::packs::types::Chain { ins: ins0 } = chain;
                    let vec2 = ins0;
                    let len2 = vec2.len();
                    let layout2 = _rt::alloc::Layout::from_size_align_unchecked(vec2.len() * 8, 4);
                    let result2 = if layout2.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout2).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout2);
                        }
                        ptr
                    } else {
                        {
                            ::core::ptr::null_mut()
                        }
                    };
                    for (i, e) in vec2.into_iter().enumerate() {
                        let base = result2.add(i * 8);
                        {
                            let vec1 = e;
                            let ptr1 = vec1.as_ptr().cast::<u8>();
                            let len1 = vec1.len();
                            *base.add(4).cast::<usize>() = len1;
                            *base.add(0).cast::<*mut u8>() = ptr1.cast_mut();
                        }
                    }

                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "acts:packs/act")]
                    extern "C" {
                        #[link_name = "push-chain"]
                        fn wit_import(_: *mut u8, _: usize);
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: usize) {
                        unreachable!()
                    }
                    wit_import(result2, len2);
                    if layout2.size() != 0 {
                        _rt::alloc::dealloc(result2.cast(), layout2);
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn push_each(each: &Each) {
                unsafe {
                    let super::super::super::acts::packs::types::Each { ins: ins0 } = each;
                    let vec2 = ins0;
                    let len2 = vec2.len();
                    let layout2 = _rt::alloc::Layout::from_size_align_unchecked(vec2.len() * 8, 4);
                    let result2 = if layout2.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout2).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout2);
                        }
                        ptr
                    } else {
                        {
                            ::core::ptr::null_mut()
                        }
                    };
                    for (i, e) in vec2.into_iter().enumerate() {
                        let base = result2.add(i * 8);
                        {
                            let vec1 = e;
                            let ptr1 = vec1.as_ptr().cast::<u8>();
                            let len1 = vec1.len();
                            *base.add(4).cast::<usize>() = len1;
                            *base.add(0).cast::<*mut u8>() = ptr1.cast_mut();
                        }
                    }

                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "acts:packs/act")]
                    extern "C" {
                        #[link_name = "push-each"]
                        fn wit_import(_: *mut u8, _: usize);
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: usize) {
                        unreachable!()
                    }
                    wit_import(result2, len2);
                    if layout2.size() != 0 {
                        _rt::alloc::dealloc(result2.cast(), layout2);
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn push_block(block: &[Packet], next: Option<&[Packet]>) {
                unsafe {
                    let mut cleanup_list = _rt::Vec::new();
                    let vec45 = block;
                    let len45 = vec45.len();
                    let layout45 =
                        _rt::alloc::Layout::from_size_align_unchecked(vec45.len() * 64, 4);
                    let result45 = if layout45.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout45).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout45);
                        }
                        ptr
                    } else {
                        {
                            ::core::ptr::null_mut()
                        }
                    };
                    for (i, e) in vec45.into_iter().enumerate() {
                        let base = result45.add(i * 64);
                        {
                            use super::super::super::acts::packs::types::Packet as V44;
                            match e {
                                V44::Req(e) => {
                                    *base.add(0).cast::<u8>() = (0i32) as u8;
                                    let super::super::super::acts::packs::types::Request {
                                        id: id0,
                                        key: key0,
                                        tag: tag0,
                                        name: name0,
                                        inputs: inputs0,
                                        outputs: outputs0,
                                    } = e;
                                    let vec1 = id0;
                                    let ptr1 = vec1.as_ptr().cast::<u8>();
                                    let len1 = vec1.len();
                                    *base.add(8).cast::<usize>() = len1;
                                    *base.add(4).cast::<*mut u8>() = ptr1.cast_mut();
                                    match key0 {
                                        Some(e) => {
                                            *base.add(12).cast::<u8>() = (1i32) as u8;
                                            let vec2 = e;
                                            let ptr2 = vec2.as_ptr().cast::<u8>();
                                            let len2 = vec2.len();
                                            *base.add(20).cast::<usize>() = len2;
                                            *base.add(16).cast::<*mut u8>() = ptr2.cast_mut();
                                        }
                                        None => {
                                            *base.add(12).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    match tag0 {
                                        Some(e) => {
                                            *base.add(24).cast::<u8>() = (1i32) as u8;
                                            let vec3 = e;
                                            let ptr3 = vec3.as_ptr().cast::<u8>();
                                            let len3 = vec3.len();
                                            *base.add(32).cast::<usize>() = len3;
                                            *base.add(28).cast::<*mut u8>() = ptr3.cast_mut();
                                        }
                                        None => {
                                            *base.add(24).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    match name0 {
                                        Some(e) => {
                                            *base.add(36).cast::<u8>() = (1i32) as u8;
                                            let vec4 = e;
                                            let ptr4 = vec4.as_ptr().cast::<u8>();
                                            let len4 = vec4.len();
                                            *base.add(44).cast::<usize>() = len4;
                                            *base.add(40).cast::<*mut u8>() = ptr4.cast_mut();
                                        }
                                        None => {
                                            *base.add(36).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    let vec9 = inputs0;
                                    let len9 = vec9.len();
                                    let layout9 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec9.len() * 24,
                                        8,
                                    );
                                    let result9 = if layout9.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout9).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout9);
                                        }
                                        ptr
                                    } else {
                                        {
                                            ::core::ptr::null_mut()
                                        }
                                    };
                                    for (i, e) in vec9.into_iter().enumerate() {
                                        let base = result9.add(i * 24);
                                        {
                                            let (t5_0, t5_1) = e;
                                            let vec6 = t5_0;
                                            let ptr6 = vec6.as_ptr().cast::<u8>();
                                            let len6 = vec6.len();
                                            *base.add(4).cast::<usize>() = len6;
                                            *base.add(0).cast::<*mut u8>() = ptr6.cast_mut();
                                            use super::super::super::acts::packs::types::Value as V8;
                                            match t5_1 {
                                                V8::Null => {
                                                    *base.add(8).cast::<u8>() = (0i32) as u8;
                                                }
                                                V8::Boolean(e) => {
                                                    *base.add(8).cast::<u8>() = (1i32) as u8;
                                                    *base.add(16).cast::<u8>() = (match e {
                                                        true => 1,
                                                        false => 0,
                                                    })
                                                        as u8;
                                                }
                                                V8::PosInt(e) => {
                                                    *base.add(8).cast::<u8>() = (2i32) as u8;
                                                    *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                                }
                                                V8::NegInt(e) => {
                                                    *base.add(8).cast::<u8>() = (3i32) as u8;
                                                    *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                                }
                                                V8::Float(e) => {
                                                    *base.add(8).cast::<u8>() = (4i32) as u8;
                                                    *base.add(16).cast::<f64>() = _rt::as_f64(e);
                                                }
                                                V8::Text(e) => {
                                                    *base.add(8).cast::<u8>() = (5i32) as u8;
                                                    let vec7 = e;
                                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                                    let len7 = vec7.len();
                                                    *base.add(20).cast::<usize>() = len7;
                                                    *base.add(16).cast::<*mut u8>() =
                                                        ptr7.cast_mut();
                                                }
                                            }
                                        }
                                    }
                                    *base.add(52).cast::<usize>() = len9;
                                    *base.add(48).cast::<*mut u8>() = result9;
                                    let vec14 = outputs0;
                                    let len14 = vec14.len();
                                    let layout14 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec14.len() * 24,
                                        8,
                                    );
                                    let result14 = if layout14.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout14).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout14);
                                        }
                                        ptr
                                    } else {
                                        {
                                            ::core::ptr::null_mut()
                                        }
                                    };
                                    for (i, e) in vec14.into_iter().enumerate() {
                                        let base = result14.add(i * 24);
                                        {
                                            let (t10_0, t10_1) = e;
                                            let vec11 = t10_0;
                                            let ptr11 = vec11.as_ptr().cast::<u8>();
                                            let len11 = vec11.len();
                                            *base.add(4).cast::<usize>() = len11;
                                            *base.add(0).cast::<*mut u8>() = ptr11.cast_mut();
                                            use super::super::super::acts::packs::types::Value as V13;
                                            match t10_1 {
                                                V13::Null => {
                                                    *base.add(8).cast::<u8>() = (0i32) as u8;
                                                }
                                                V13::Boolean(e) => {
                                                    *base.add(8).cast::<u8>() = (1i32) as u8;
                                                    *base.add(16).cast::<u8>() = (match e {
                                                        true => 1,
                                                        false => 0,
                                                    })
                                                        as u8;
                                                }
                                                V13::PosInt(e) => {
                                                    *base.add(8).cast::<u8>() = (2i32) as u8;
                                                    *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                                }
                                                V13::NegInt(e) => {
                                                    *base.add(8).cast::<u8>() = (3i32) as u8;
                                                    *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                                }
                                                V13::Float(e) => {
                                                    *base.add(8).cast::<u8>() = (4i32) as u8;
                                                    *base.add(16).cast::<f64>() = _rt::as_f64(e);
                                                }
                                                V13::Text(e) => {
                                                    *base.add(8).cast::<u8>() = (5i32) as u8;
                                                    let vec12 = e;
                                                    let ptr12 = vec12.as_ptr().cast::<u8>();
                                                    let len12 = vec12.len();
                                                    *base.add(20).cast::<usize>() = len12;
                                                    *base.add(16).cast::<*mut u8>() =
                                                        ptr12.cast_mut();
                                                }
                                            }
                                        }
                                    }
                                    *base.add(60).cast::<usize>() = len14;
                                    *base.add(56).cast::<*mut u8>() = result14;
                                    cleanup_list.extend_from_slice(&[
                                        (result9, layout9),
                                        (result14, layout14),
                                    ]);
                                }
                                V44::Msg(e) => {
                                    *base.add(0).cast::<u8>() = (1i32) as u8;
                                    let super::super::super::acts::packs::types::Message {
                                        id: id15,
                                        key: key15,
                                        tag: tag15,
                                        name: name15,
                                        inputs: inputs15,
                                    } = e;
                                    let vec16 = id15;
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    *base.add(8).cast::<usize>() = len16;
                                    *base.add(4).cast::<*mut u8>() = ptr16.cast_mut();
                                    match key15 {
                                        Some(e) => {
                                            *base.add(12).cast::<u8>() = (1i32) as u8;
                                            let vec17 = e;
                                            let ptr17 = vec17.as_ptr().cast::<u8>();
                                            let len17 = vec17.len();
                                            *base.add(20).cast::<usize>() = len17;
                                            *base.add(16).cast::<*mut u8>() = ptr17.cast_mut();
                                        }
                                        None => {
                                            *base.add(12).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    match tag15 {
                                        Some(e) => {
                                            *base.add(24).cast::<u8>() = (1i32) as u8;
                                            let vec18 = e;
                                            let ptr18 = vec18.as_ptr().cast::<u8>();
                                            let len18 = vec18.len();
                                            *base.add(32).cast::<usize>() = len18;
                                            *base.add(28).cast::<*mut u8>() = ptr18.cast_mut();
                                        }
                                        None => {
                                            *base.add(24).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    match name15 {
                                        Some(e) => {
                                            *base.add(36).cast::<u8>() = (1i32) as u8;
                                            let vec19 = e;
                                            let ptr19 = vec19.as_ptr().cast::<u8>();
                                            let len19 = vec19.len();
                                            *base.add(44).cast::<usize>() = len19;
                                            *base.add(40).cast::<*mut u8>() = ptr19.cast_mut();
                                        }
                                        None => {
                                            *base.add(36).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    let vec24 = inputs15;
                                    let len24 = vec24.len();
                                    let layout24 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec24.len() * 24,
                                        8,
                                    );
                                    let result24 = if layout24.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout24).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout24);
                                        }
                                        ptr
                                    } else {
                                        {
                                            ::core::ptr::null_mut()
                                        }
                                    };
                                    for (i, e) in vec24.into_iter().enumerate() {
                                        let base = result24.add(i * 24);
                                        {
                                            let (t20_0, t20_1) = e;
                                            let vec21 = t20_0;
                                            let ptr21 = vec21.as_ptr().cast::<u8>();
                                            let len21 = vec21.len();
                                            *base.add(4).cast::<usize>() = len21;
                                            *base.add(0).cast::<*mut u8>() = ptr21.cast_mut();
                                            use super::super::super::acts::packs::types::Value as V23;
                                            match t20_1 {
                                                V23::Null => {
                                                    *base.add(8).cast::<u8>() = (0i32) as u8;
                                                }
                                                V23::Boolean(e) => {
                                                    *base.add(8).cast::<u8>() = (1i32) as u8;
                                                    *base.add(16).cast::<u8>() = (match e {
                                                        true => 1,
                                                        false => 0,
                                                    })
                                                        as u8;
                                                }
                                                V23::PosInt(e) => {
                                                    *base.add(8).cast::<u8>() = (2i32) as u8;
                                                    *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                                }
                                                V23::NegInt(e) => {
                                                    *base.add(8).cast::<u8>() = (3i32) as u8;
                                                    *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                                }
                                                V23::Float(e) => {
                                                    *base.add(8).cast::<u8>() = (4i32) as u8;
                                                    *base.add(16).cast::<f64>() = _rt::as_f64(e);
                                                }
                                                V23::Text(e) => {
                                                    *base.add(8).cast::<u8>() = (5i32) as u8;
                                                    let vec22 = e;
                                                    let ptr22 = vec22.as_ptr().cast::<u8>();
                                                    let len22 = vec22.len();
                                                    *base.add(20).cast::<usize>() = len22;
                                                    *base.add(16).cast::<*mut u8>() =
                                                        ptr22.cast_mut();
                                                }
                                            }
                                        }
                                    }
                                    *base.add(52).cast::<usize>() = len24;
                                    *base.add(48).cast::<*mut u8>() = result24;
                                    cleanup_list.extend_from_slice(&[(result24, layout24)]);
                                }
                                V44::Chain(e) => {
                                    *base.add(0).cast::<u8>() = (2i32) as u8;
                                    let super::super::super::acts::packs::types::Chain {
                                        ins: ins25,
                                    } = e;
                                    let vec27 = ins25;
                                    let len27 = vec27.len();
                                    let layout27 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec27.len() * 8,
                                        4,
                                    );
                                    let result27 = if layout27.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout27).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout27);
                                        }
                                        ptr
                                    } else {
                                        {
                                            ::core::ptr::null_mut()
                                        }
                                    };
                                    for (i, e) in vec27.into_iter().enumerate() {
                                        let base = result27.add(i * 8);
                                        {
                                            let vec26 = e;
                                            let ptr26 = vec26.as_ptr().cast::<u8>();
                                            let len26 = vec26.len();
                                            *base.add(4).cast::<usize>() = len26;
                                            *base.add(0).cast::<*mut u8>() = ptr26.cast_mut();
                                        }
                                    }
                                    *base.add(8).cast::<usize>() = len27;
                                    *base.add(4).cast::<*mut u8>() = result27;
                                    cleanup_list.extend_from_slice(&[(result27, layout27)]);
                                }
                                V44::Each(e) => {
                                    *base.add(0).cast::<u8>() = (3i32) as u8;
                                    let super::super::super::acts::packs::types::Each {
                                        ins: ins28,
                                    } = e;
                                    let vec30 = ins28;
                                    let len30 = vec30.len();
                                    let layout30 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec30.len() * 8,
                                        4,
                                    );
                                    let result30 = if layout30.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout30).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout30);
                                        }
                                        ptr
                                    } else {
                                        {
                                            ::core::ptr::null_mut()
                                        }
                                    };
                                    for (i, e) in vec30.into_iter().enumerate() {
                                        let base = result30.add(i * 8);
                                        {
                                            let vec29 = e;
                                            let ptr29 = vec29.as_ptr().cast::<u8>();
                                            let len29 = vec29.len();
                                            *base.add(4).cast::<usize>() = len29;
                                            *base.add(0).cast::<*mut u8>() = ptr29.cast_mut();
                                        }
                                    }
                                    *base.add(8).cast::<usize>() = len30;
                                    *base.add(4).cast::<*mut u8>() = result30;
                                    cleanup_list.extend_from_slice(&[(result30, layout30)]);
                                }
                                V44::Call(e) => {
                                    *base.add(0).cast::<u8>() = (4i32) as u8;
                                    let super::super::super::acts::packs::types::Call {
                                        id: id31,
                                        mid: mid31,
                                        inputs: inputs31,
                                        outputs: outputs31,
                                    } = e;
                                    let vec32 = id31;
                                    let ptr32 = vec32.as_ptr().cast::<u8>();
                                    let len32 = vec32.len();
                                    *base.add(8).cast::<usize>() = len32;
                                    *base.add(4).cast::<*mut u8>() = ptr32.cast_mut();
                                    let vec33 = mid31;
                                    let ptr33 = vec33.as_ptr().cast::<u8>();
                                    let len33 = vec33.len();
                                    *base.add(16).cast::<usize>() = len33;
                                    *base.add(12).cast::<*mut u8>() = ptr33.cast_mut();
                                    let vec38 = inputs31;
                                    let len38 = vec38.len();
                                    let layout38 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec38.len() * 24,
                                        8,
                                    );
                                    let result38 = if layout38.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout38).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout38);
                                        }
                                        ptr
                                    } else {
                                        {
                                            ::core::ptr::null_mut()
                                        }
                                    };
                                    for (i, e) in vec38.into_iter().enumerate() {
                                        let base = result38.add(i * 24);
                                        {
                                            let (t34_0, t34_1) = e;
                                            let vec35 = t34_0;
                                            let ptr35 = vec35.as_ptr().cast::<u8>();
                                            let len35 = vec35.len();
                                            *base.add(4).cast::<usize>() = len35;
                                            *base.add(0).cast::<*mut u8>() = ptr35.cast_mut();
                                            use super::super::super::acts::packs::types::Value as V37;
                                            match t34_1 {
                                                V37::Null => {
                                                    *base.add(8).cast::<u8>() = (0i32) as u8;
                                                }
                                                V37::Boolean(e) => {
                                                    *base.add(8).cast::<u8>() = (1i32) as u8;
                                                    *base.add(16).cast::<u8>() = (match e {
                                                        true => 1,
                                                        false => 0,
                                                    })
                                                        as u8;
                                                }
                                                V37::PosInt(e) => {
                                                    *base.add(8).cast::<u8>() = (2i32) as u8;
                                                    *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                                }
                                                V37::NegInt(e) => {
                                                    *base.add(8).cast::<u8>() = (3i32) as u8;
                                                    *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                                }
                                                V37::Float(e) => {
                                                    *base.add(8).cast::<u8>() = (4i32) as u8;
                                                    *base.add(16).cast::<f64>() = _rt::as_f64(e);
                                                }
                                                V37::Text(e) => {
                                                    *base.add(8).cast::<u8>() = (5i32) as u8;
                                                    let vec36 = e;
                                                    let ptr36 = vec36.as_ptr().cast::<u8>();
                                                    let len36 = vec36.len();
                                                    *base.add(20).cast::<usize>() = len36;
                                                    *base.add(16).cast::<*mut u8>() =
                                                        ptr36.cast_mut();
                                                }
                                            }
                                        }
                                    }
                                    *base.add(24).cast::<usize>() = len38;
                                    *base.add(20).cast::<*mut u8>() = result38;
                                    let vec43 = outputs31;
                                    let len43 = vec43.len();
                                    let layout43 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec43.len() * 24,
                                        8,
                                    );
                                    let result43 = if layout43.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout43).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout43);
                                        }
                                        ptr
                                    } else {
                                        {
                                            ::core::ptr::null_mut()
                                        }
                                    };
                                    for (i, e) in vec43.into_iter().enumerate() {
                                        let base = result43.add(i * 24);
                                        {
                                            let (t39_0, t39_1) = e;
                                            let vec40 = t39_0;
                                            let ptr40 = vec40.as_ptr().cast::<u8>();
                                            let len40 = vec40.len();
                                            *base.add(4).cast::<usize>() = len40;
                                            *base.add(0).cast::<*mut u8>() = ptr40.cast_mut();
                                            use super::super::super::acts::packs::types::Value as V42;
                                            match t39_1 {
                                                V42::Null => {
                                                    *base.add(8).cast::<u8>() = (0i32) as u8;
                                                }
                                                V42::Boolean(e) => {
                                                    *base.add(8).cast::<u8>() = (1i32) as u8;
                                                    *base.add(16).cast::<u8>() = (match e {
                                                        true => 1,
                                                        false => 0,
                                                    })
                                                        as u8;
                                                }
                                                V42::PosInt(e) => {
                                                    *base.add(8).cast::<u8>() = (2i32) as u8;
                                                    *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                                }
                                                V42::NegInt(e) => {
                                                    *base.add(8).cast::<u8>() = (3i32) as u8;
                                                    *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                                }
                                                V42::Float(e) => {
                                                    *base.add(8).cast::<u8>() = (4i32) as u8;
                                                    *base.add(16).cast::<f64>() = _rt::as_f64(e);
                                                }
                                                V42::Text(e) => {
                                                    *base.add(8).cast::<u8>() = (5i32) as u8;
                                                    let vec41 = e;
                                                    let ptr41 = vec41.as_ptr().cast::<u8>();
                                                    let len41 = vec41.len();
                                                    *base.add(20).cast::<usize>() = len41;
                                                    *base.add(16).cast::<*mut u8>() =
                                                        ptr41.cast_mut();
                                                }
                                            }
                                        }
                                    }
                                    *base.add(32).cast::<usize>() = len43;
                                    *base.add(28).cast::<*mut u8>() = result43;
                                    cleanup_list.extend_from_slice(&[
                                        (result38, layout38),
                                        (result43, layout43),
                                    ]);
                                }
                            }
                        }
                    }
                    let (result92_0, result92_1, result92_2) = match next {
                        Some(e) => {
                            let vec91 = e;
                            let len91 = vec91.len();
                            let layout91 =
                                _rt::alloc::Layout::from_size_align_unchecked(vec91.len() * 64, 4);
                            let result91 = if layout91.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout91).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout91);
                                }
                                ptr
                            } else {
                                {
                                    ::core::ptr::null_mut()
                                }
                            };
                            for (i, e) in vec91.into_iter().enumerate() {
                                let base = result91.add(i * 64);
                                {
                                    use super::super::super::acts::packs::types::Packet as V90;
                                    match e {
                                        V90::Req(e) => {
                                            *base.add(0).cast::<u8>() = (0i32) as u8;
                                            let super::super::super::acts::packs::types::Request {
                                                id: id46,
                                                key: key46,
                                                tag: tag46,
                                                name: name46,
                                                inputs: inputs46,
                                                outputs: outputs46,
                                            } = e;
                                            let vec47 = id46;
                                            let ptr47 = vec47.as_ptr().cast::<u8>();
                                            let len47 = vec47.len();
                                            *base.add(8).cast::<usize>() = len47;
                                            *base.add(4).cast::<*mut u8>() = ptr47.cast_mut();
                                            match key46 {
                                                Some(e) => {
                                                    *base.add(12).cast::<u8>() = (1i32) as u8;
                                                    let vec48 = e;
                                                    let ptr48 = vec48.as_ptr().cast::<u8>();
                                                    let len48 = vec48.len();
                                                    *base.add(20).cast::<usize>() = len48;
                                                    *base.add(16).cast::<*mut u8>() =
                                                        ptr48.cast_mut();
                                                }
                                                None => {
                                                    *base.add(12).cast::<u8>() = (0i32) as u8;
                                                }
                                            };
                                            match tag46 {
                                                Some(e) => {
                                                    *base.add(24).cast::<u8>() = (1i32) as u8;
                                                    let vec49 = e;
                                                    let ptr49 = vec49.as_ptr().cast::<u8>();
                                                    let len49 = vec49.len();
                                                    *base.add(32).cast::<usize>() = len49;
                                                    *base.add(28).cast::<*mut u8>() =
                                                        ptr49.cast_mut();
                                                }
                                                None => {
                                                    *base.add(24).cast::<u8>() = (0i32) as u8;
                                                }
                                            };
                                            match name46 {
                                                Some(e) => {
                                                    *base.add(36).cast::<u8>() = (1i32) as u8;
                                                    let vec50 = e;
                                                    let ptr50 = vec50.as_ptr().cast::<u8>();
                                                    let len50 = vec50.len();
                                                    *base.add(44).cast::<usize>() = len50;
                                                    *base.add(40).cast::<*mut u8>() =
                                                        ptr50.cast_mut();
                                                }
                                                None => {
                                                    *base.add(36).cast::<u8>() = (0i32) as u8;
                                                }
                                            };
                                            let vec55 = inputs46;
                                            let len55 = vec55.len();
                                            let layout55 =
                                                _rt::alloc::Layout::from_size_align_unchecked(
                                                    vec55.len() * 24,
                                                    8,
                                                );
                                            let result55 = if layout55.size() != 0 {
                                                let ptr = _rt::alloc::alloc(layout55).cast::<u8>();
                                                if ptr.is_null() {
                                                    _rt::alloc::handle_alloc_error(layout55);
                                                }
                                                ptr
                                            } else {
                                                {
                                                    ::core::ptr::null_mut()
                                                }
                                            };
                                            for (i, e) in vec55.into_iter().enumerate() {
                                                let base = result55.add(i * 24);
                                                {
                                                    let (t51_0, t51_1) = e;
                                                    let vec52 = t51_0;
                                                    let ptr52 = vec52.as_ptr().cast::<u8>();
                                                    let len52 = vec52.len();
                                                    *base.add(4).cast::<usize>() = len52;
                                                    *base.add(0).cast::<*mut u8>() =
                                                        ptr52.cast_mut();
                                                    use super::super::super::acts::packs::types::Value as V54;
                                                    match t51_1 {
                                                        V54::Null => {
                                                            *base.add(8).cast::<u8>() =
                                                                (0i32) as u8;
                                                        }
                                                        V54::Boolean(e) => {
                                                            *base.add(8).cast::<u8>() =
                                                                (1i32) as u8;
                                                            *base.add(16).cast::<u8>() = (match e {
                                                                true => 1,
                                                                false => 0,
                                                            })
                                                                as u8;
                                                        }
                                                        V54::PosInt(e) => {
                                                            *base.add(8).cast::<u8>() =
                                                                (2i32) as u8;
                                                            *base.add(16).cast::<i64>() =
                                                                _rt::as_i64(e);
                                                        }
                                                        V54::NegInt(e) => {
                                                            *base.add(8).cast::<u8>() =
                                                                (3i32) as u8;
                                                            *base.add(16).cast::<i64>() =
                                                                _rt::as_i64(e);
                                                        }
                                                        V54::Float(e) => {
                                                            *base.add(8).cast::<u8>() =
                                                                (4i32) as u8;
                                                            *base.add(16).cast::<f64>() =
                                                                _rt::as_f64(e);
                                                        }
                                                        V54::Text(e) => {
                                                            *base.add(8).cast::<u8>() =
                                                                (5i32) as u8;
                                                            let vec53 = e;
                                                            let ptr53 = vec53.as_ptr().cast::<u8>();
                                                            let len53 = vec53.len();
                                                            *base.add(20).cast::<usize>() = len53;
                                                            *base.add(16).cast::<*mut u8>() =
                                                                ptr53.cast_mut();
                                                        }
                                                    }
                                                }
                                            }
                                            *base.add(52).cast::<usize>() = len55;
                                            *base.add(48).cast::<*mut u8>() = result55;
                                            let vec60 = outputs46;
                                            let len60 = vec60.len();
                                            let layout60 =
                                                _rt::alloc::Layout::from_size_align_unchecked(
                                                    vec60.len() * 24,
                                                    8,
                                                );
                                            let result60 = if layout60.size() != 0 {
                                                let ptr = _rt::alloc::alloc(layout60).cast::<u8>();
                                                if ptr.is_null() {
                                                    _rt::alloc::handle_alloc_error(layout60);
                                                }
                                                ptr
                                            } else {
                                                {
                                                    ::core::ptr::null_mut()
                                                }
                                            };
                                            for (i, e) in vec60.into_iter().enumerate() {
                                                let base = result60.add(i * 24);
                                                {
                                                    let (t56_0, t56_1) = e;
                                                    let vec57 = t56_0;
                                                    let ptr57 = vec57.as_ptr().cast::<u8>();
                                                    let len57 = vec57.len();
                                                    *base.add(4).cast::<usize>() = len57;
                                                    *base.add(0).cast::<*mut u8>() =
                                                        ptr57.cast_mut();
                                                    use super::super::super::acts::packs::types::Value as V59;
                                                    match t56_1 {
                                                        V59::Null => {
                                                            *base.add(8).cast::<u8>() =
                                                                (0i32) as u8;
                                                        }
                                                        V59::Boolean(e) => {
                                                            *base.add(8).cast::<u8>() =
                                                                (1i32) as u8;
                                                            *base.add(16).cast::<u8>() = (match e {
                                                                true => 1,
                                                                false => 0,
                                                            })
                                                                as u8;
                                                        }
                                                        V59::PosInt(e) => {
                                                            *base.add(8).cast::<u8>() =
                                                                (2i32) as u8;
                                                            *base.add(16).cast::<i64>() =
                                                                _rt::as_i64(e);
                                                        }
                                                        V59::NegInt(e) => {
                                                            *base.add(8).cast::<u8>() =
                                                                (3i32) as u8;
                                                            *base.add(16).cast::<i64>() =
                                                                _rt::as_i64(e);
                                                        }
                                                        V59::Float(e) => {
                                                            *base.add(8).cast::<u8>() =
                                                                (4i32) as u8;
                                                            *base.add(16).cast::<f64>() =
                                                                _rt::as_f64(e);
                                                        }
                                                        V59::Text(e) => {
                                                            *base.add(8).cast::<u8>() =
                                                                (5i32) as u8;
                                                            let vec58 = e;
                                                            let ptr58 = vec58.as_ptr().cast::<u8>();
                                                            let len58 = vec58.len();
                                                            *base.add(20).cast::<usize>() = len58;
                                                            *base.add(16).cast::<*mut u8>() =
                                                                ptr58.cast_mut();
                                                        }
                                                    }
                                                }
                                            }
                                            *base.add(60).cast::<usize>() = len60;
                                            *base.add(56).cast::<*mut u8>() = result60;
                                            cleanup_list.extend_from_slice(&[
                                                (result55, layout55),
                                                (result60, layout60),
                                            ]);
                                        }
                                        V90::Msg(e) => {
                                            *base.add(0).cast::<u8>() = (1i32) as u8;
                                            let super::super::super::acts::packs::types::Message {
                                                id: id61,
                                                key: key61,
                                                tag: tag61,
                                                name: name61,
                                                inputs: inputs61,
                                            } = e;
                                            let vec62 = id61;
                                            let ptr62 = vec62.as_ptr().cast::<u8>();
                                            let len62 = vec62.len();
                                            *base.add(8).cast::<usize>() = len62;
                                            *base.add(4).cast::<*mut u8>() = ptr62.cast_mut();
                                            match key61 {
                                                Some(e) => {
                                                    *base.add(12).cast::<u8>() = (1i32) as u8;
                                                    let vec63 = e;
                                                    let ptr63 = vec63.as_ptr().cast::<u8>();
                                                    let len63 = vec63.len();
                                                    *base.add(20).cast::<usize>() = len63;
                                                    *base.add(16).cast::<*mut u8>() =
                                                        ptr63.cast_mut();
                                                }
                                                None => {
                                                    *base.add(12).cast::<u8>() = (0i32) as u8;
                                                }
                                            };
                                            match tag61 {
                                                Some(e) => {
                                                    *base.add(24).cast::<u8>() = (1i32) as u8;
                                                    let vec64 = e;
                                                    let ptr64 = vec64.as_ptr().cast::<u8>();
                                                    let len64 = vec64.len();
                                                    *base.add(32).cast::<usize>() = len64;
                                                    *base.add(28).cast::<*mut u8>() =
                                                        ptr64.cast_mut();
                                                }
                                                None => {
                                                    *base.add(24).cast::<u8>() = (0i32) as u8;
                                                }
                                            };
                                            match name61 {
                                                Some(e) => {
                                                    *base.add(36).cast::<u8>() = (1i32) as u8;
                                                    let vec65 = e;
                                                    let ptr65 = vec65.as_ptr().cast::<u8>();
                                                    let len65 = vec65.len();
                                                    *base.add(44).cast::<usize>() = len65;
                                                    *base.add(40).cast::<*mut u8>() =
                                                        ptr65.cast_mut();
                                                }
                                                None => {
                                                    *base.add(36).cast::<u8>() = (0i32) as u8;
                                                }
                                            };
                                            let vec70 = inputs61;
                                            let len70 = vec70.len();
                                            let layout70 =
                                                _rt::alloc::Layout::from_size_align_unchecked(
                                                    vec70.len() * 24,
                                                    8,
                                                );
                                            let result70 = if layout70.size() != 0 {
                                                let ptr = _rt::alloc::alloc(layout70).cast::<u8>();
                                                if ptr.is_null() {
                                                    _rt::alloc::handle_alloc_error(layout70);
                                                }
                                                ptr
                                            } else {
                                                {
                                                    ::core::ptr::null_mut()
                                                }
                                            };
                                            for (i, e) in vec70.into_iter().enumerate() {
                                                let base = result70.add(i * 24);
                                                {
                                                    let (t66_0, t66_1) = e;
                                                    let vec67 = t66_0;
                                                    let ptr67 = vec67.as_ptr().cast::<u8>();
                                                    let len67 = vec67.len();
                                                    *base.add(4).cast::<usize>() = len67;
                                                    *base.add(0).cast::<*mut u8>() =
                                                        ptr67.cast_mut();
                                                    use super::super::super::acts::packs::types::Value as V69;
                                                    match t66_1 {
                                                        V69::Null => {
                                                            *base.add(8).cast::<u8>() =
                                                                (0i32) as u8;
                                                        }
                                                        V69::Boolean(e) => {
                                                            *base.add(8).cast::<u8>() =
                                                                (1i32) as u8;
                                                            *base.add(16).cast::<u8>() = (match e {
                                                                true => 1,
                                                                false => 0,
                                                            })
                                                                as u8;
                                                        }
                                                        V69::PosInt(e) => {
                                                            *base.add(8).cast::<u8>() =
                                                                (2i32) as u8;
                                                            *base.add(16).cast::<i64>() =
                                                                _rt::as_i64(e);
                                                        }
                                                        V69::NegInt(e) => {
                                                            *base.add(8).cast::<u8>() =
                                                                (3i32) as u8;
                                                            *base.add(16).cast::<i64>() =
                                                                _rt::as_i64(e);
                                                        }
                                                        V69::Float(e) => {
                                                            *base.add(8).cast::<u8>() =
                                                                (4i32) as u8;
                                                            *base.add(16).cast::<f64>() =
                                                                _rt::as_f64(e);
                                                        }
                                                        V69::Text(e) => {
                                                            *base.add(8).cast::<u8>() =
                                                                (5i32) as u8;
                                                            let vec68 = e;
                                                            let ptr68 = vec68.as_ptr().cast::<u8>();
                                                            let len68 = vec68.len();
                                                            *base.add(20).cast::<usize>() = len68;
                                                            *base.add(16).cast::<*mut u8>() =
                                                                ptr68.cast_mut();
                                                        }
                                                    }
                                                }
                                            }
                                            *base.add(52).cast::<usize>() = len70;
                                            *base.add(48).cast::<*mut u8>() = result70;
                                            cleanup_list.extend_from_slice(&[(result70, layout70)]);
                                        }
                                        V90::Chain(e) => {
                                            *base.add(0).cast::<u8>() = (2i32) as u8;
                                            let super::super::super::acts::packs::types::Chain {
                                                ins: ins71,
                                            } = e;
                                            let vec73 = ins71;
                                            let len73 = vec73.len();
                                            let layout73 =
                                                _rt::alloc::Layout::from_size_align_unchecked(
                                                    vec73.len() * 8,
                                                    4,
                                                );
                                            let result73 = if layout73.size() != 0 {
                                                let ptr = _rt::alloc::alloc(layout73).cast::<u8>();
                                                if ptr.is_null() {
                                                    _rt::alloc::handle_alloc_error(layout73);
                                                }
                                                ptr
                                            } else {
                                                {
                                                    ::core::ptr::null_mut()
                                                }
                                            };
                                            for (i, e) in vec73.into_iter().enumerate() {
                                                let base = result73.add(i * 8);
                                                {
                                                    let vec72 = e;
                                                    let ptr72 = vec72.as_ptr().cast::<u8>();
                                                    let len72 = vec72.len();
                                                    *base.add(4).cast::<usize>() = len72;
                                                    *base.add(0).cast::<*mut u8>() =
                                                        ptr72.cast_mut();
                                                }
                                            }
                                            *base.add(8).cast::<usize>() = len73;
                                            *base.add(4).cast::<*mut u8>() = result73;
                                            cleanup_list.extend_from_slice(&[(result73, layout73)]);
                                        }
                                        V90::Each(e) => {
                                            *base.add(0).cast::<u8>() = (3i32) as u8;
                                            let super::super::super::acts::packs::types::Each {
                                                ins: ins74,
                                            } = e;
                                            let vec76 = ins74;
                                            let len76 = vec76.len();
                                            let layout76 =
                                                _rt::alloc::Layout::from_size_align_unchecked(
                                                    vec76.len() * 8,
                                                    4,
                                                );
                                            let result76 = if layout76.size() != 0 {
                                                let ptr = _rt::alloc::alloc(layout76).cast::<u8>();
                                                if ptr.is_null() {
                                                    _rt::alloc::handle_alloc_error(layout76);
                                                }
                                                ptr
                                            } else {
                                                {
                                                    ::core::ptr::null_mut()
                                                }
                                            };
                                            for (i, e) in vec76.into_iter().enumerate() {
                                                let base = result76.add(i * 8);
                                                {
                                                    let vec75 = e;
                                                    let ptr75 = vec75.as_ptr().cast::<u8>();
                                                    let len75 = vec75.len();
                                                    *base.add(4).cast::<usize>() = len75;
                                                    *base.add(0).cast::<*mut u8>() =
                                                        ptr75.cast_mut();
                                                }
                                            }
                                            *base.add(8).cast::<usize>() = len76;
                                            *base.add(4).cast::<*mut u8>() = result76;
                                            cleanup_list.extend_from_slice(&[(result76, layout76)]);
                                        }
                                        V90::Call(e) => {
                                            *base.add(0).cast::<u8>() = (4i32) as u8;
                                            let super::super::super::acts::packs::types::Call {
                                                id: id77,
                                                mid: mid77,
                                                inputs: inputs77,
                                                outputs: outputs77,
                                            } = e;
                                            let vec78 = id77;
                                            let ptr78 = vec78.as_ptr().cast::<u8>();
                                            let len78 = vec78.len();
                                            *base.add(8).cast::<usize>() = len78;
                                            *base.add(4).cast::<*mut u8>() = ptr78.cast_mut();
                                            let vec79 = mid77;
                                            let ptr79 = vec79.as_ptr().cast::<u8>();
                                            let len79 = vec79.len();
                                            *base.add(16).cast::<usize>() = len79;
                                            *base.add(12).cast::<*mut u8>() = ptr79.cast_mut();
                                            let vec84 = inputs77;
                                            let len84 = vec84.len();
                                            let layout84 =
                                                _rt::alloc::Layout::from_size_align_unchecked(
                                                    vec84.len() * 24,
                                                    8,
                                                );
                                            let result84 = if layout84.size() != 0 {
                                                let ptr = _rt::alloc::alloc(layout84).cast::<u8>();
                                                if ptr.is_null() {
                                                    _rt::alloc::handle_alloc_error(layout84);
                                                }
                                                ptr
                                            } else {
                                                {
                                                    ::core::ptr::null_mut()
                                                }
                                            };
                                            for (i, e) in vec84.into_iter().enumerate() {
                                                let base = result84.add(i * 24);
                                                {
                                                    let (t80_0, t80_1) = e;
                                                    let vec81 = t80_0;
                                                    let ptr81 = vec81.as_ptr().cast::<u8>();
                                                    let len81 = vec81.len();
                                                    *base.add(4).cast::<usize>() = len81;
                                                    *base.add(0).cast::<*mut u8>() =
                                                        ptr81.cast_mut();
                                                    use super::super::super::acts::packs::types::Value as V83;
                                                    match t80_1 {
                                                        V83::Null => {
                                                            *base.add(8).cast::<u8>() =
                                                                (0i32) as u8;
                                                        }
                                                        V83::Boolean(e) => {
                                                            *base.add(8).cast::<u8>() =
                                                                (1i32) as u8;
                                                            *base.add(16).cast::<u8>() = (match e {
                                                                true => 1,
                                                                false => 0,
                                                            })
                                                                as u8;
                                                        }
                                                        V83::PosInt(e) => {
                                                            *base.add(8).cast::<u8>() =
                                                                (2i32) as u8;
                                                            *base.add(16).cast::<i64>() =
                                                                _rt::as_i64(e);
                                                        }
                                                        V83::NegInt(e) => {
                                                            *base.add(8).cast::<u8>() =
                                                                (3i32) as u8;
                                                            *base.add(16).cast::<i64>() =
                                                                _rt::as_i64(e);
                                                        }
                                                        V83::Float(e) => {
                                                            *base.add(8).cast::<u8>() =
                                                                (4i32) as u8;
                                                            *base.add(16).cast::<f64>() =
                                                                _rt::as_f64(e);
                                                        }
                                                        V83::Text(e) => {
                                                            *base.add(8).cast::<u8>() =
                                                                (5i32) as u8;
                                                            let vec82 = e;
                                                            let ptr82 = vec82.as_ptr().cast::<u8>();
                                                            let len82 = vec82.len();
                                                            *base.add(20).cast::<usize>() = len82;
                                                            *base.add(16).cast::<*mut u8>() =
                                                                ptr82.cast_mut();
                                                        }
                                                    }
                                                }
                                            }
                                            *base.add(24).cast::<usize>() = len84;
                                            *base.add(20).cast::<*mut u8>() = result84;
                                            let vec89 = outputs77;
                                            let len89 = vec89.len();
                                            let layout89 =
                                                _rt::alloc::Layout::from_size_align_unchecked(
                                                    vec89.len() * 24,
                                                    8,
                                                );
                                            let result89 = if layout89.size() != 0 {
                                                let ptr = _rt::alloc::alloc(layout89).cast::<u8>();
                                                if ptr.is_null() {
                                                    _rt::alloc::handle_alloc_error(layout89);
                                                }
                                                ptr
                                            } else {
                                                {
                                                    ::core::ptr::null_mut()
                                                }
                                            };
                                            for (i, e) in vec89.into_iter().enumerate() {
                                                let base = result89.add(i * 24);
                                                {
                                                    let (t85_0, t85_1) = e;
                                                    let vec86 = t85_0;
                                                    let ptr86 = vec86.as_ptr().cast::<u8>();
                                                    let len86 = vec86.len();
                                                    *base.add(4).cast::<usize>() = len86;
                                                    *base.add(0).cast::<*mut u8>() =
                                                        ptr86.cast_mut();
                                                    use super::super::super::acts::packs::types::Value as V88;
                                                    match t85_1 {
                                                        V88::Null => {
                                                            *base.add(8).cast::<u8>() =
                                                                (0i32) as u8;
                                                        }
                                                        V88::Boolean(e) => {
                                                            *base.add(8).cast::<u8>() =
                                                                (1i32) as u8;
                                                            *base.add(16).cast::<u8>() = (match e {
                                                                true => 1,
                                                                false => 0,
                                                            })
                                                                as u8;
                                                        }
                                                        V88::PosInt(e) => {
                                                            *base.add(8).cast::<u8>() =
                                                                (2i32) as u8;
                                                            *base.add(16).cast::<i64>() =
                                                                _rt::as_i64(e);
                                                        }
                                                        V88::NegInt(e) => {
                                                            *base.add(8).cast::<u8>() =
                                                                (3i32) as u8;
                                                            *base.add(16).cast::<i64>() =
                                                                _rt::as_i64(e);
                                                        }
                                                        V88::Float(e) => {
                                                            *base.add(8).cast::<u8>() =
                                                                (4i32) as u8;
                                                            *base.add(16).cast::<f64>() =
                                                                _rt::as_f64(e);
                                                        }
                                                        V88::Text(e) => {
                                                            *base.add(8).cast::<u8>() =
                                                                (5i32) as u8;
                                                            let vec87 = e;
                                                            let ptr87 = vec87.as_ptr().cast::<u8>();
                                                            let len87 = vec87.len();
                                                            *base.add(20).cast::<usize>() = len87;
                                                            *base.add(16).cast::<*mut u8>() =
                                                                ptr87.cast_mut();
                                                        }
                                                    }
                                                }
                                            }
                                            *base.add(32).cast::<usize>() = len89;
                                            *base.add(28).cast::<*mut u8>() = result89;
                                            cleanup_list.extend_from_slice(&[
                                                (result84, layout84),
                                                (result89, layout89),
                                            ]);
                                        }
                                    }
                                }
                            }
                            cleanup_list.extend_from_slice(&[(result91, layout91)]);

                            (1i32, result91, len91)
                        }
                        None => (0i32, ::core::ptr::null_mut(), 0usize),
                    };
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "acts:packs/act")]
                    extern "C" {
                        #[link_name = "push-block"]
                        fn wit_import(_: *mut u8, _: usize, _: i32, _: *mut u8, _: usize);
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: usize, _: i32, _: *mut u8, _: usize) {
                        unreachable!()
                    }
                    wit_import(result45, len45, result92_0, result92_1, result92_2);
                    if layout45.size() != 0 {
                        _rt::alloc::dealloc(result45.cast(), layout45);
                    }
                    for (ptr, layout) in cleanup_list {
                        if layout.size() != 0 {
                            _rt::alloc::dealloc(ptr.cast(), layout);
                        }
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn push_call(c: &Call) {
                unsafe {
                    let super::super::super::acts::packs::types::Call {
                        id: id0,
                        mid: mid0,
                        inputs: inputs0,
                        outputs: outputs0,
                    } = c;
                    let vec1 = id0;
                    let ptr1 = vec1.as_ptr().cast::<u8>();
                    let len1 = vec1.len();
                    let vec2 = mid0;
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();
                    let vec7 = inputs0;
                    let len7 = vec7.len();
                    let layout7 = _rt::alloc::Layout::from_size_align_unchecked(vec7.len() * 24, 8);
                    let result7 = if layout7.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout7).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout7);
                        }
                        ptr
                    } else {
                        {
                            ::core::ptr::null_mut()
                        }
                    };
                    for (i, e) in vec7.into_iter().enumerate() {
                        let base = result7.add(i * 24);
                        {
                            let (t3_0, t3_1) = e;
                            let vec4 = t3_0;
                            let ptr4 = vec4.as_ptr().cast::<u8>();
                            let len4 = vec4.len();
                            *base.add(4).cast::<usize>() = len4;
                            *base.add(0).cast::<*mut u8>() = ptr4.cast_mut();
                            use super::super::super::acts::packs::types::Value as V6;
                            match t3_1 {
                                V6::Null => {
                                    *base.add(8).cast::<u8>() = (0i32) as u8;
                                }
                                V6::Boolean(e) => {
                                    *base.add(8).cast::<u8>() = (1i32) as u8;
                                    *base.add(16).cast::<u8>() = (match e {
                                        true => 1,
                                        false => 0,
                                    })
                                        as u8;
                                }
                                V6::PosInt(e) => {
                                    *base.add(8).cast::<u8>() = (2i32) as u8;
                                    *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                }
                                V6::NegInt(e) => {
                                    *base.add(8).cast::<u8>() = (3i32) as u8;
                                    *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                }
                                V6::Float(e) => {
                                    *base.add(8).cast::<u8>() = (4i32) as u8;
                                    *base.add(16).cast::<f64>() = _rt::as_f64(e);
                                }
                                V6::Text(e) => {
                                    *base.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec5 = e;
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    *base.add(20).cast::<usize>() = len5;
                                    *base.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                                }
                            }
                        }
                    }
                    let vec12 = outputs0;
                    let len12 = vec12.len();
                    let layout12 =
                        _rt::alloc::Layout::from_size_align_unchecked(vec12.len() * 24, 8);
                    let result12 = if layout12.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout12).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout12);
                        }
                        ptr
                    } else {
                        {
                            ::core::ptr::null_mut()
                        }
                    };
                    for (i, e) in vec12.into_iter().enumerate() {
                        let base = result12.add(i * 24);
                        {
                            let (t8_0, t8_1) = e;
                            let vec9 = t8_0;
                            let ptr9 = vec9.as_ptr().cast::<u8>();
                            let len9 = vec9.len();
                            *base.add(4).cast::<usize>() = len9;
                            *base.add(0).cast::<*mut u8>() = ptr9.cast_mut();
                            use super::super::super::acts::packs::types::Value as V11;
                            match t8_1 {
                                V11::Null => {
                                    *base.add(8).cast::<u8>() = (0i32) as u8;
                                }
                                V11::Boolean(e) => {
                                    *base.add(8).cast::<u8>() = (1i32) as u8;
                                    *base.add(16).cast::<u8>() = (match e {
                                        true => 1,
                                        false => 0,
                                    })
                                        as u8;
                                }
                                V11::PosInt(e) => {
                                    *base.add(8).cast::<u8>() = (2i32) as u8;
                                    *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                }
                                V11::NegInt(e) => {
                                    *base.add(8).cast::<u8>() = (3i32) as u8;
                                    *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                }
                                V11::Float(e) => {
                                    *base.add(8).cast::<u8>() = (4i32) as u8;
                                    *base.add(16).cast::<f64>() = _rt::as_f64(e);
                                }
                                V11::Text(e) => {
                                    *base.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec10 = e;
                                    let ptr10 = vec10.as_ptr().cast::<u8>();
                                    let len10 = vec10.len();
                                    *base.add(20).cast::<usize>() = len10;
                                    *base.add(16).cast::<*mut u8>() = ptr10.cast_mut();
                                }
                            }
                        }
                    }

                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "acts:packs/act")]
                    extern "C" {
                        #[link_name = "push-call"]
                        fn wit_import(
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                        );
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                    ) {
                        unreachable!()
                    }
                    wit_import(
                        ptr1.cast_mut(),
                        len1,
                        ptr2.cast_mut(),
                        len2,
                        result7,
                        len7,
                        result12,
                        len12,
                    );
                    if layout7.size() != 0 {
                        _rt::alloc::dealloc(result7.cast(), layout7);
                    }
                    if layout12.size() != 0 {
                        _rt::alloc::dealloc(result12.cast(), layout12);
                    }
                }
            }
        }

        #[allow(clippy::all)]
        pub mod log {
            #[used]
            #[doc(hidden)]
            #[cfg(target_arch = "wasm32")]
            static __FORCE_SECTION_REF: fn() =
                super::super::super::__link_custom_section_describing_imports;
            #[allow(unused_unsafe, clippy::all)]
            pub fn info(message: &str) {
                unsafe {
                    let vec0 = message;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();

                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "acts:packs/log")]
                    extern "C" {
                        #[link_name = "info"]
                        fn wit_import(_: *mut u8, _: usize);
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: usize) {
                        unreachable!()
                    }
                    wit_import(ptr0.cast_mut(), len0);
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn error(message: &str) {
                unsafe {
                    let vec0 = message;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();

                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "acts:packs/log")]
                    extern "C" {
                        #[link_name = "error"]
                        fn wit_import(_: *mut u8, _: usize);
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: usize) {
                        unreachable!()
                    }
                    wit_import(ptr0.cast_mut(), len0);
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn warn(message: &str) {
                unsafe {
                    let vec0 = message;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();

                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "acts:packs/log")]
                    extern "C" {
                        #[link_name = "warn"]
                        fn wit_import(_: *mut u8, _: usize);
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: usize) {
                        unreachable!()
                    }
                    wit_import(ptr0.cast_mut(), len0);
                }
            }
        }
    }
}
mod _rt {
    pub use alloc_crate::string::String;
    pub use alloc_crate::vec::Vec;
    pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
        if cfg!(debug_assertions) {
            String::from_utf8(bytes).unwrap()
        } else {
            String::from_utf8_unchecked(bytes)
        }
    }
    pub unsafe fn bool_lift(val: u8) -> bool {
        if cfg!(debug_assertions) {
            match val {
                0 => false,
                1 => true,
                _ => panic!("invalid bool discriminant"),
            }
        } else {
            ::core::mem::transmute::<u8, bool>(val)
        }
    }
    pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
        if size == 0 {
            return;
        }
        let layout = alloc::Layout::from_size_align_unchecked(size, align);
        alloc::dealloc(ptr as *mut u8, layout);
    }

    pub fn as_i64<T: AsI64>(t: T) -> i64 {
        t.as_i64()
    }

    pub trait AsI64 {
        fn as_i64(self) -> i64;
    }

    impl<'a, T: Copy + AsI64> AsI64 for &'a T {
        fn as_i64(self) -> i64 {
            (*self).as_i64()
        }
    }

    impl AsI64 for i64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }

    impl AsI64 for u64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }

    pub fn as_f64<T: AsF64>(t: T) -> f64 {
        t.as_f64()
    }

    pub trait AsF64 {
        fn as_f64(self) -> f64;
    }

    impl<'a, T: Copy + AsF64> AsF64 for &'a T {
        fn as_f64(self) -> f64 {
            (*self).as_f64()
        }
    }

    impl AsF64 for f64 {
        #[inline]
        fn as_f64(self) -> f64 {
            self as f64
        }
    }
    pub use alloc_crate::alloc;
    extern crate alloc as alloc_crate;
}

/// Generates `#[no_mangle]` functions to export the specified type as the
/// root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]

macro_rules! __export_pack_impl {
  ($ty:ident) => (self::export!($ty with_types_in self););
  ($ty:ident with_types_in $($path_to_types_root:tt)*) => (
  $($path_to_types_root)*::__export_world_pack_cabi!($ty with_types_in $($path_to_types_root)*);
  )
}
#[doc(inline)]
pub(crate) use __export_pack_impl as export;

#[cfg(target_arch = "wasm32")]
#[link_section = "component-type:wit-bindgen:0.21.0:pack:encoded world"]
#[doc(hidden)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 1218] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xc7\x08\x01A\x02\x01\
A\x10\x01B\x16\x01q\x06\x04null\0\0\x07boolean\x01\x7f\0\x07pos-int\x01w\0\x07ne\
g-int\x01x\0\x05float\x01u\0\x04text\x01s\0\x04\0\x05value\x03\0\0\x01o\x02s\x01\
\x01p\x02\x04\0\x03map\x03\0\x03\x01ks\x01r\x06\x02ids\x03key\x05\x03tag\x05\x04\
name\x05\x06inputs\x04\x07outputs\x04\x04\0\x07request\x03\0\x06\x01r\x05\x02ids\
\x03key\x05\x03tag\x05\x04name\x05\x06inputs\x04\x04\0\x07message\x03\0\x08\x01p\
s\x01r\x01\x03ins\x0a\x04\0\x05chain\x03\0\x0b\x01r\x01\x03ins\x0a\x04\0\x04each\
\x03\0\x0d\x01r\x04\x02ids\x03mids\x06inputs\x04\x07outputs\x04\x04\0\x04call\x03\
\0\x0f\x01q\x05\x03req\x01\x07\0\x03msg\x01\x09\0\x05chain\x01\x0c\0\x04each\x01\
\x0e\0\x04call\x01\x10\0\x04\0\x06packet\x03\0\x11\x01p\x12\x01r\x02\x0aon-creat\
ed\x13\x0con-completed\x13\x04\0\x0erequest-events\x03\0\x14\x03\x01\x10acts:pac\
ks/types\x05\0\x02\x03\0\0\x05value\x02\x03\0\0\x07request\x02\x03\0\0\x07messag\
e\x02\x03\0\0\x06packet\x02\x03\0\0\x04call\x02\x03\0\0\x05chain\x02\x03\0\0\x04\
each\x02\x03\0\0\x0erequest-events\x01B/\x02\x03\x02\x01\x01\x04\0\x05value\x03\0\
\0\x02\x03\x02\x01\x02\x04\0\x07request\x03\0\x02\x02\x03\x02\x01\x03\x04\0\x07m\
essage\x03\0\x04\x02\x03\x02\x01\x04\x04\0\x06packet\x03\0\x06\x02\x03\x02\x01\x05\
\x04\0\x04call\x03\0\x08\x02\x03\x02\x01\x06\x04\0\x05chain\x03\0\x0a\x02\x03\x02\
\x01\x07\x04\0\x04each\x03\0\x0c\x02\x03\x02\x01\x08\x04\0\x0erequest-events\x03\
\0\x0e\x01o\x02s\x01\x01p\x10\x01@\0\0\x11\x04\0\x06inputs\x01\x12\x01@\x02\x03k\
eys\x05value\x01\x01\0\x04\0\x08set-data\x01\x13\x04\0\x0aset-output\x01\x13\x01\
@\0\x01\0\x04\0\x08complete\x01\x14\x04\0\x05abort\x01\x14\x01@\x01\x03nids\x01\0\
\x04\0\x04back\x01\x15\x01@\x02\x05ecodes\x07messages\x01\0\x04\0\x04fail\x01\x16\
\x04\0\x04skip\x01\x14\x01@\x01\x01p\x07\x01\0\x04\0\x04push\x01\x17\x01@\x02\x03\
req\x03\x06events\x0f\x01\0\x04\0\x08push-req\x01\x18\x01@\x01\x05chain\x05\x01\0\
\x04\0\x08push-msg\x01\x19\x01@\x01\x05chain\x0b\x01\0\x04\0\x0apush-chain\x01\x1a\
\x01@\x01\x04each\x0d\x01\0\x04\0\x09push-each\x01\x1b\x01p\x07\x01k\x1c\x01@\x02\
\x05block\x1c\x04next\x1d\x01\0\x04\0\x0apush-block\x01\x1e\x01@\x01\x01c\x09\x01\
\0\x04\0\x09push-call\x01\x1f\x03\x01\x0eacts:packs/act\x05\x09\x01B\x04\x01@\x01\
\x07messages\x01\0\x04\0\x04info\x01\0\x04\0\x05error\x01\0\x04\0\x04warn\x01\0\x03\
\x01\x0eacts:packs/log\x05\x0a\x01@\0\x01\0\x04\0\x03run\x01\x0b\x04\x01\x0facts\
:packs/pack\x04\0\x0b\x0a\x01\0\x04pack\x03\0\0\0G\x09producers\x01\x0cprocessed\
-by\x02\x0dwit-component\x070.201.0\x10wit-bindgen-rust\x060.21.0";

#[inline(never)]
#[doc(hidden)]
#[cfg(target_arch = "wasm32")]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen_rt::maybe_link_cabi_realloc();
}
